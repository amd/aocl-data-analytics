!
!  L-BFGS-B is released under the “New BSD License” (aka “Modified BSD License”
!  or “3-clause license”)
!  Please read attached file License.txt
!
!===========   L-BFGS-B (version 3.0.  April 25, 2011  ===================
!
!     This is a modified version of L-BFGS-B. Minor changes in the updated
!     code appear preceded by a line comment as follows
!
!     c-jlm-jn
!
!     Major changes are described in the accompanying paper:
!
!         Jorge Nocedal and Jose Luis Morales, Remark on "Algorithm 778:
!         L-BFGS-B: Fortran Subroutines for Large-Scale Bound Constrained
!         Optimization"  (2011). To appear in  ACM Transactions on
!         Mathematical Software,
!
!     The paper describes an improvement and a correction to Algorithm 778.
!     It is shown that the performance of the algorithm can be improved
!     significantly by making a relatively simple modication to the subspace
!     minimization phase. The correction concerns an error caused by the use
!     of routine dpmeps to estimate machine precision.
!
!     The total work space **wa** required by the new version is
!
!                  2*m*n + 11m*m + 5*n + 8*m
!
!     the old version required
!
!                  2*m*n + 12m*m + 4*n + 12*m
!
!
!            J. Nocedal  Department of Electrical Engineering and
!                        Computer Science.
!                        Northwestern University. Evanston, IL. USA
!
!
!           J.L Morales  Departamento de Matematicas,
!                        Instituto Tecnologico Autonomo de Mexico
!                        Mexico D.F. Mexico.
!
!                        March  2011
!
!=============================================================================
#include "preprocessor.FPP"

    Subroutine PREC(setulb)(n, m, x, l, u, nbd, f, g, factr, pgtol, wa, iwa, task, &
      iprint, csave, lsave, isave, dsave)
#ifdef SINGLE_PREC
      Use sworking_precision, Only: wp
#else
      Use dworking_precision, Only: wp
#endif

      Character (60) :: task, csave
      Logical :: lsave(4)
      Integer :: n, m, iprint, nbd(n), iwa(3*n), isave(44)
!
!-jlm-jn
      Real (Kind=wp) :: f, factr, pgtol, x(n), l(n), u(n), g(n), &
        wa(2*m*n+5*n+11*m*m+8*m), dsave(29)

!     ************
!
!     Subroutine setulb
!
!     This subroutine partitions the working arrays wa and iwa, and
!       then uses the limited memory BFGS method to solve the bound
!       constrained optimization problem by calling mainlb.
!       (The direct method will be used in the subspace minimization.)
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x is an approximation to the solution.
!       On exit x is the current approximation.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound on x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound on x.
!       On exit u is unchanged.
!
!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     f is a double precision variable.
!       On first entry f is unspecified.
!       On final exit f is the value of the function at x.
!
!     g is a double precision array of dimension n.
!       On first entry g is unspecified.
!       On final exit g is the value of the gradient at x.
!
!     factr is a double precision variable.
!       On entry factr >= 0 is specified by the user.  The iteration
!         will stop when
!
!         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
!
!         where epsmch is the machine precision, which is automatically
!         generated by the code. Typical values for factr: 1.d+12 for
!         low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
!         high accuracy.
!       On exit factr is unchanged.
!
!     pgtol is a double precision variable.
!       On entry pgtol >= 0 is specified by the user.  The iteration
!         will stop when
!
!                 max{|proj g_i | i = 1, ..., n} <= pgtol
!
!         where pg_i is the ith component of the projected gradient.
!       On exit pgtol is unchanged.
!
!     wa is a double precision working array of length
!       (2mmax + 5)nmax + 12mmax^2 + 12mmax.
!
!     iwa is an integer working array of length 3nmax.
!
!     task is a working string of characters of length 60 indicating
!       the current job when entering and quitting this subroutine.
!
!     iprint is an integer variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     csave is a working string of characters of length 60.
!
!     lsave is a logical working array of dimension 4.
!       On exit with 'task' = NEW_X, the following information is
!                                                             available:
!         If lsave(1) = .true.  then  the initial X has been replaced by
!                                     its projection in the feasible set;
!         If lsave(2) = .true.  then  the problem is constrained;
!         If lsave(3) = .true.  then  each variable has upper and lower
!                                     bounds;
!
!     isave is an integer working array of dimension 44.
!       On exit with 'task' = NEW_X, the following information is
!                                                             available:
!         isave(22) = the total number of intervals explored in the
!                         search of Cauchy points;
!         isave(26) = the total number of skipped BFGS updates before
!                         the current iteration;
!         isave(30) = the number of current iteration;
!         isave(31) = the total number of BFGS updates prior the current
!                         iteration;
!         isave(33) = the number of intervals explored in the search of
!                         Cauchy point in the current iteration;
!         isave(34) = the total number of function and gradient
!                         evaluations;
!         isave(36) = the number of function value or gradient
!                                  evaluations in the current iteration;
!         if isave(37) = 0  then the subspace argmin is within the box;
!         if isave(37) = 1  then the subspace argmin is beyond the box;
!         isave(38) = the number of free variables in the current
!                         iteration;
!         isave(39) = the number of active constraints in the current
!                         iteration;
!         n + 1 - isave(40) = the number of variables leaving the set of
!                           active constraints in the current iteration;
!         isave(41) = the number of variables entering the set of active
!                         constraints in the current iteration.
!
!     dsave is a double precision working array of dimension 29.
!       On exit with 'task' = NEW_X, the following information is
!                                                             available:
!         dsave(1) = current 'theta' in the BFGS matrix;
!         dsave(2) = f(x) in the previous iteration;
!         dsave(3) = factr*epsmch;
!         dsave(4) = 2-norm of the line search direction vector;
!         dsave(5) = the machine precision epsmch generated by the code;
!         dsave(7) = the accumulated time spent on searching for
!                                                         Cauchy points;
!         dsave(8) = the accumulated time spent on
!                                                 subspace minimization;
!         dsave(9) = the accumulated time spent on line search;
!         dsave(11) = the slope of the line search function at
!                                  the current point of line search;
!         dsave(12) = the maximum relative step length imposed in
!                                                           line search;
!         dsave(13) = the infinity norm of the projected gradient;
!         dsave(14) = the relative step length in the line search;
!         dsave(15) = the slope of the line search function at
!                                 the starting point of the line search;
!         dsave(16) = the square of the 2-norm of the line search
!                                                      direction vector.
!
!     Subprograms called:
!
!       L-BFGS-B Library ... mainlb.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
!       limited memory FORTRAN code for solving bound constrained
!       optimization problems'', Tech. Report, NAM-11, EECS Department,
!       Northwestern University, 1994.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
!-jlm-jn
      Integer :: lws, lr, lz, lt, ld, lxp, lwa, lwy, lsy, lss, lwt, lwn, lsnd

      If (task=='START') Then
        isave(1) = m*n
        isave(2) = m**2
        isave(3) = 4*m**2
        isave(4) = 1 ! ws      m*n
        isave(5) = isave(4) + isave(1) ! wy      m*n
        isave(6) = isave(5) + isave(1) ! wsy     m**2
        isave(7) = isave(6) + isave(2) ! wss     m**2
        isave(8) = isave(7) + isave(2) ! wt      m**2
        isave(9) = isave(8) + isave(2) ! wn      4*m**2
        isave(10) = isave(9) + isave(3) ! wsnd    4*m**2
        isave(11) = isave(10) + isave(3) ! wz      n
        isave(12) = isave(11) + n ! wr      n
        isave(13) = isave(12) + n ! wd      n
        isave(14) = isave(13) + n ! wt      n
        isave(15) = isave(14) + n ! wxp     n
        isave(16) = isave(15) + n ! wa      8*m
        isave(44) = wp ! inform back to user the working precision id
      End If
      lws = isave(4)
      lwy = isave(5)
      lsy = isave(6)
      lss = isave(7)
      lwt = isave(8)
      lwn = isave(9)
      lsnd = isave(10)
      lz = isave(11)
      lr = isave(12)
      ld = isave(13)
      lt = isave(14)
      lxp = isave(15)
      lwa = isave(16)

      Call PREC(mainlb)(n, m, x, l, u, nbd, f, g, factr, pgtol, wa(lws), wa(lwy), &
        wa(lsy), wa(lss), wa(lwt), wa(lwn), wa(lsnd), wa(lz), wa(lr), wa(ld), &
        wa(lt), wa(lxp), wa(lwa), iwa(1), iwa(n+1), iwa(2*n+1), task, iprint, &
        csave, lsave, isave(22), dsave)

      Return

    End Subroutine

!======================= The end of setulb =============================

    Subroutine PREC(mainlb)(n, m, x, l, u, nbd, f, g, factr, pgtol, ws, wy, sy, ss, &
      wt, wn, snd, z, r, d, t, xp, wa, index, iwhere, indx2, task, iprint, &
      csave, lsave, isave, dsave)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif
      Implicit None
      Character (60) :: task, csave
      Logical :: lsave(4)
      Integer :: n, m, iprint, nbd(n), index(n), iwhere(n), indx2(n), &
        isave(23)
!-jlm-jn
      Real (Kind=wp) :: f, factr, pgtol, x(n), l(n), u(n), g(n), z(n), r(n), &
        d(n), t(n), xp(n), wa(8*m), ws(n, m), wy(n, m), sy(m, m), ss(m, m), &
        wt(m, m), wn(2*m, 2*m), snd(2*m, 2*m), dsave(29)

!     ************
!
!     Subroutine mainlb
!
!     This subroutine solves bound constrained optimization problems by
!       using the compact formula of the limited memory BFGS updates.
!
!     n is an integer variable.
!       On entry n is the number of variables.
!       On exit n is unchanged.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric
!          corrections allowed in the limited memory matrix.
!       On exit m is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x is an approximation to the solution.
!       On exit x is the current approximation.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.
!
!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds,
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     f is a double precision variable.
!       On first entry f is unspecified.
!       On final exit f is the value of the function at x.
!
!     g is a double precision array of dimension n.
!       On first entry g is unspecified.
!       On final exit g is the value of the gradient at x.
!
!     factr is a double precision variable.
!       On entry factr >= 0 is specified by the user.  The iteration
!         will stop when
!
!         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
!
!         where epsmch is the machine precision, which is automatically
!         generated by the code.
!       On exit factr is unchanged.
!
!     pgtol is a double precision variable.
!       On entry pgtol >= 0 is specified by the user.  The iteration
!         will stop when
!
!                 max{|proj g_i | i = 1, ..., n} <= pgtol
!
!         where pg_i is the ith component of the projected gradient.
!       On exit pgtol is unchanged.
!
!     ws, wy, sy, and wt are double precision working arrays used to
!       store the following information defining the limited memory
!          BFGS matrix:
!          ws, of dimension n x m, stores S, the matrix of s-vectors;
!          wy, of dimension n x m, stores Y, the matrix of y-vectors;
!          sy, of dimension m x m, stores S'Y;
!          ss, of dimension m x m, stores S'S;
!          yy, of dimension m x m, stores Y'Y;
!          wt, of dimension m x m, stores the Cholesky factorization
!                                  of (theta*S'S+LD^(-1)L'); see eq.
!                                  (2.26) in [3].
!
!     wn is a double precision working array of dimension 2m x 2m
!       used to store the LEL^T factorization of the indefinite matrix
!                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!
!       where     E = [-I  0]
!                     [ 0  I]
!
!     snd is a double precision working array of dimension 2m x 2m
!       used to store the lower triangular part of
!                 N = [Y' ZZ'Y   L_a'+R_z']
!                     [L_a +R_z  S'AA'S   ]
!
!     z(n),r(n),d(n),t(n), xp(n),wa(8*m) are double precision working arrays.
!       z  is used at different times to store the Cauchy point and
!          the Newton point.
!       xp is used to safeguard the projected Newton direction
!
!     sg(m),sgo(m),yg(m),ygo(m) are double precision working arrays.
!
!     index is an integer working array of dimension n.
!       In subroutine freev, index is used to store the free and fixed
!          variables at the Generalized Cauchy Point (GCP).
!
!     iwhere is an integer working array of dimension n used to record
!       the status of the vector x for GCP computation.
!       iwhere(i)=0 or -3 if x(i) is free and has bounds,
!                 1       if x(i) is fixed at l(i), and l(i) .ne. u(i)
!                 2       if x(i) is fixed at u(i), and u(i) .ne. l(i)
!                 3       if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
!                -1       if x(i) is always free, i.e., no bounds on it.
!
!     indx2 is an integer working array of dimension n.
!       Within subroutine cauchy, indx2 corresponds to the array iorder.
!       In subroutine freev, a list of variables entering and leaving
!       the free set is stored in indx2, and it is passed on to
!       subroutine formk with this information.
!
!     task is a working string of characters of length 60 indicating
!       the current job when entering and leaving this subroutine.
!
!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     csave is a working string of characters of length 60.
!
!     lsave is a logical working array of dimension 4.
!
!     isave is an integer working array of dimension 23.
!
!     dsave is a double precision working array of dimension 29.
!
!
!     Subprograms called
!
!       L-BFGS-B Library ... cauchy, subsm, lnsrlb, formk,
!
!        errclb, prn1lb, prn2lb, prn3lb, active, projgr,
!
!        freev, cmprlb, matupd, formt.
!
!       Minpack2 Library ... timer
!
!       Linpack Library ... dcopy, ddot.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN
!       Subroutines for Large Scale Bound Constrained Optimization''
!       Tech. Report, NAM-11, EECS Department, Northwestern University,
!       1994.
!
!       [3] R. Byrd, J. Nocedal and R. Schnabel "Representations of
!       Quasi-Newton Matrices and their use in Limited Memory Methods'',
!       Mathematical Programming 63 (1994), no. 4, pp. 129-156.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Logical :: prjctd, cnstnd, boxed, updatd, wrk
      Character (3) :: word
      Integer :: i, k, nintol, itfile, iback, nskip, head, col, iter, itail, &
        iupdat, nseg, nfgv, info, ifun, iword, nfree, nact, ileave, nenter
      Real (Kind=wp) :: theta, fold, PREC(dot), dr, rr, tol, xstep, sbgnrm, ddum, &
        dnorm, dtd, epsmch, cpu1, cpu2, cachyt, sbtime, lnscht, time1, time2, &
        gd, gdold, stp, stpmx, time
      Real (Kind=wp) :: one, zero
      Parameter (one=1.0E0_wp, zero=0.0E0_wp)

      If (task=='START') Then

        epsmch = epsilon(one)

        Call PREC(timer)(time1)

!        Initialize counters and scalars when task='START'.

!           for the limited memory BFGS matrices:
        col = 0
        head = 1
        theta = one
        iupdat = 0
        updatd = .False.
        iback = 0
        itail = 0
        iword = 0
        nact = 0
        ileave = 0
        nenter = 0
        fold = zero
        dnorm = zero
        cpu1 = zero
        gd = zero
        stpmx = zero
        sbgnrm = zero
        stp = zero
        gdold = zero
        dtd = zero

!           for operation counts:
        iter = 0
        nfgv = 0
        nseg = 0
        nintol = 0
        nskip = 0
        nfree = n
        ifun = 0
!           for stopping tolerance:
        tol = factr*epsmch

!           for measuring running time:
        cachyt = 0
        sbtime = 0
        lnscht = 0

!           'word' records the status of subspace solutions.
        word = '---'

!           'info' records the termination information.
        info = 0

        itfile = 0
        If (iprint>=1 .And. itfile/=0) Then
!                                open a summary file 'iterate.dat'
          Open (8, File='iterate.dat', Status='unknown')
        End If

!        Check the input arguments for errors.

        Call PREC(errclb)(n, m, factr, l, u, nbd, task, info, k)
        If (task(1:5)=='ERROR') Then
          Call PREC(prn3lb)(n, x, f, task, iprint, info, itfile, iter, nfgv, nintol, &
            nskip, nact, sbgnrm, zero, nseg, word, iback, stp, xstep, k, &
            cachyt, sbtime, lnscht)
          Return
        End If

        Call PREC(prn1lb)(n, m, l, u, x, iprint, itfile, epsmch)

!        Initialize iwhere & project x onto the feasible set.

        Call PREC(active)(n, l, u, nbd, x, iwhere, iprint, prjctd, cnstnd, boxed)

!        The end of the initialization.

      Else
!          restore local variables.

        prjctd = lsave(1)
        cnstnd = lsave(2)
        boxed = lsave(3)
        updatd = lsave(4)

        nintol = isave(1)
        itfile = isave(3)
        iback = isave(4)
        nskip = isave(5)
        head = isave(6)
        col = isave(7)
        itail = isave(8)
        iter = isave(9)
        iupdat = isave(10)
        nseg = isave(12)
        nfgv = isave(13)
        info = isave(14)
        ifun = isave(15)
        iword = isave(16)
        nfree = isave(17)
        nact = isave(18)
        ileave = isave(19)
        nenter = isave(20)

        theta = dsave(1)
        fold = dsave(2)
        tol = dsave(3)
        dnorm = dsave(4)
        epsmch = dsave(5)
        cpu1 = dsave(6)
        cachyt = dsave(7)
        sbtime = dsave(8)
        lnscht = dsave(9)
        time1 = dsave(10)
        gd = dsave(11)
        stpmx = dsave(12)
        sbgnrm = dsave(13)
        stp = dsave(14)
        gdold = dsave(15)
        dtd = dsave(16)

!        After returning from the driver go to the point where execution
!        is to resume.

        If (task(1:5)=='FG_LN') Go To 150
        If (task(1:5)=='NEW_X') Go To 160
        If (task(1:5)=='FG_ST') Go To 100
        If (task(1:4)=='STOP') Then
          If (task(7:9)=='CPU') Then
!                                          restore the previous iterate.
            Call PREC(copy)(n, t, 1, x, 1)
            Call PREC(copy)(n, r, 1, g, 1)
            f = fold
          End If
          Go To 180
        End If
      End If

!     Compute f0 and g0.

      task = 'FG_START'
!          return to the driver to calculate f and g; reenter at 111.
      Go To 190
100   Continue
      nfgv = 1

!     Compute the infinity norm of the (-) projected gradient.

      Call PREC(projgr)(n, l, u, nbd, x, g, sbgnrm)

      If (iprint>=1) Then
        Write (6, 210) iter, f, sbgnrm
        If (itfile/=0) Write (itfile, 220) iter, nfgv, sbgnrm, f
      End If
      If (sbgnrm<=pgtol) Then
!                                terminate the algorithm.
        task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL'
        Go To 180
      End If

! ----------------- the beginning of the loop --------------------------

110   Continue
      If (iprint>=99) Write (6, 200) iter + 1
      iword = -1
!
      If (.Not. cnstnd .And. col>0) Then
!                                            skip the search for GCP.
        Call PREC(copy)(n, x, 1, z, 1)
        wrk = updatd
        nseg = 0
        Go To 120
      End If

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Compute the Generalized Cauchy Point (GCP).
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      Call PREC(timer)(cpu1)
      Call PREC(cauchy)(n, x, l, u, nbd, g, indx2, iwhere, t, d, z, m, wy, ws, sy, &
        wt, theta, col, head, wa(1), wa(2*m+1), wa(4*m+1), wa(6*m+1), nseg, &
        iprint, sbgnrm, info, epsmch)
      If (info/=0) Then
!         singular triangular system detected; refresh the lbfgs memory.
        If (iprint>=1) Write (6, 240)
        info = 0
        col = 0
        head = 1
        theta = one
        iupdat = 0
        updatd = .False.
        Call PREC(timer)(cpu2)
        cachyt = cachyt + cpu2 - cpu1
        Go To 110
      End If
      Call PREC(timer)(cpu2)
      cachyt = cachyt + cpu2 - cpu1
      nintol = nintol + nseg

!     Count the entering and leaving variables for iter > 0;
!     find the index set of free and active variables at the GCP.

      Call PREC(freev)(n, nfree, index, nenter, ileave, indx2, iwhere, wrk, updatd, &
        cnstnd, iprint, iter)
      nact = n - nfree

120   Continue

!     If there are no free variables or B=theta*I, then
!                                        skip the subspace minimization.

      If (nfree==0 .Or. col==0) Go To 140

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Subspace minimization.
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      Call PREC(timer)(cpu1)

!     Form  the LEL^T factorization of the indefinite
!       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!       where     E = [-I  0]
!                     [ 0  I]

      If (wrk) Call PREC(formk)(n, nfree, index, nenter, ileave, indx2, iupdat, &
        updatd, wn, snd, m, ws, wy, sy, theta, col, head, info)
      If (info/=0) Then
!          nonpositive definiteness in Cholesky factorization;
!          refresh the lbfgs memory and restart the iteration.
        If (iprint>=1) Write (6, 250)
        info = 0
        col = 0
        head = 1
        theta = one
        iupdat = 0
        updatd = .False.
        Call PREC(timer)(cpu2)
        sbtime = sbtime + cpu2 - cpu1
        Go To 110
      End If

!        compute r=-Z'B(xcp-xk)-Z'g (using wa(2m+1)=W'(xcp-x)
!                                                   from 'cauchy').
      Call PREC(cmprlb)(n, m, x, g, ws, wy, sy, wt, z, r, wa, index, theta, col, &
        head, nfree, cnstnd, info)
      If (info/=0) Go To 130

!-jlm-jn   call the direct method.

      Call PREC(subsm)(n, m, nfree, index, l, u, nbd, z, r, xp, ws, wy, theta, x, g, &
        col, head, iword, wa, wn, iprint, info)
130   Continue
      If (info/=0) Then
!          singular triangular system detected;
!          refresh the lbfgs memory and restart the iteration.
        If (iprint>=1) Write (6, 240)
        info = 0
        col = 0
        head = 1
        theta = one
        iupdat = 0
        updatd = .False.
        Call PREC(timer)(cpu2)
        sbtime = sbtime + cpu2 - cpu1
        Go To 110
      End If

      Call PREC(timer)(cpu2)
      sbtime = sbtime + cpu2 - cpu1
140   Continue

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Line search and optimality tests.
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!     Generate the search direction d:=z-x.

      Do i = 1, n
        d(i) = z(i) - x(i)
      End Do
      Call PREC(timer)(cpu1)
150   Continue
      Call PREC(lnsrlb)(n, l, u, nbd, x, f, fold, gd, gdold, g, d, r, t, z, stp, &
        dnorm, dtd, xstep, stpmx, iter, ifun, iback, nfgv, info, task, boxed, &
        cnstnd, csave, isave(22), dsave(17))
      If (info/=0 .Or. iback>=20) Then
!          restore the previous iterate.
        Call PREC(copy)(n, t, 1, x, 1)
        Call PREC(copy)(n, r, 1, g, 1)
        f = fold
        If (col==0) Then
!             abnormal termination.
          If (info==0) Then
            info = -9
!                restore the actual number of f and g evaluations etc.
            nfgv = nfgv - 1
            ifun = ifun - 1
            iback = iback - 1
          End If
          task = 'ABNORMAL_TERMINATION_IN_LNSRCH'
          iter = iter + 1
          Go To 180
        Else
!             refresh the lbfgs memory and restart the iteration.
          If (iprint>=1) Write (6, 270)
          If (info==0) nfgv = nfgv - 1
          info = 0
          col = 0
          head = 1
          theta = one
          iupdat = 0
          updatd = .False.
          task = 'RESTART_FROM_LNSRCH'
          Call PREC(timer)(cpu2)
          lnscht = lnscht + cpu2 - cpu1
          Go To 110
        End If
      Else If (task(1:5)=='FG_LN') Then
!          return to the driver for calculating f and g; reenter at 666.
        Go To 190
      Else
!          calculate and print out the quantities related to the new X.
        Call PREC(timer)(cpu2)
        lnscht = lnscht + cpu2 - cpu1
        iter = iter + 1

!        Compute the infinity norm of the projected (-)gradient.

        Call PREC(projgr)(n, l, u, nbd, x, g, sbgnrm)

!        Print iteration information.

        Call PREC(prn2lb)(n, x, f, g, iprint, itfile, iter, nfgv, nact, sbgnrm, &
          nseg, word, iword, iback, stp, xstep)
        Go To 190
      End If
160   Continue

!     Test for termination.

      If (sbgnrm<=pgtol) Then
!                                terminate the algorithm.
        task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL'
        Go To 180
      End If

      ddum = max(abs(fold), abs(f), one)
      If ((fold-f)<=tol*ddum) Then
!                                        terminate the algorithm.
        task = 'CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH'
        If (iback>=10) info = -5
!           i.e., to issue a warning if iback>10 in the line search.
        Go To 180
      End If

!     Compute d=newx-oldx, r=newg-oldg, rr=y'y and dr=y's.

      Do i = 1, n
        r(i) = g(i) - r(i)
      End Do
      rr = PREC(dot)(n, r, 1, r, 1)
      If (stp==one) Then
        dr = gd - gdold
        ddum = -gdold
      Else
        dr = (gd-gdold)*stp
        Call PREC(scal)(n, stp, d, 1)
        ddum = -gdold*stp
      End If

      If (dr<=epsmch*ddum) Then
!                            skip the L-BFGS update.
        nskip = nskip + 1
        updatd = .False.
        If (iprint>=1) Write (6, 230) dr, ddum
        Go To 170
      End If

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Update the L-BFGS matrix.
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      updatd = .True.
      iupdat = iupdat + 1

!     Update matrices WS and WY and form the middle matrix in B.

      Call PREC(matupd)(n, m, ws, wy, sy, ss, d, r, itail, iupdat, col, head, theta, &
        rr, dr, stp, dtd)

!     Form the upper half of the pds T = theta*SS + L*D^(-1)*L';
!        Store T in the upper triangular of the array wt;
!        Cholesky factorize T to J*J' with
!           J' stored in the upper triangular of wt.

      Call PREC(formt)(m, wt, sy, ss, col, theta, info)

      If (info/=0) Then
!          nonpositive definiteness in Cholesky factorization;
!          refresh the lbfgs memory and restart the iteration.
        If (iprint>=1) Write (6, 260)
        info = 0
        col = 0
        head = 1
        theta = one
        iupdat = 0
        updatd = .False.
        Go To 110
      End If

!     Now the inverse of the middle matrix in B is

!       [  D^(1/2)      O ] [ -D^(1/2)  D^(-1/2)*L' ]
!       [ -L*D^(-1/2)   J ] [  0        J'          ]

170   Continue

! -------------------- the end of the loop -----------------------------

      Go To 110
180   Continue
      Call PREC(timer)(time2)
      time = time2 - time1
      Call PREC(prn3lb)(n, x, f, task, iprint, info, itfile, iter, nfgv, nintol, &
        nskip, nact, sbgnrm, time, nseg, word, iback, stp, xstep, k, cachyt, &
        sbtime, lnscht)
190   Continue

!     Save local variables.

      lsave(1) = prjctd
      lsave(2) = cnstnd
      lsave(3) = boxed
      lsave(4) = updatd

      isave(1) = nintol
      isave(3) = itfile
      isave(4) = iback
      isave(5) = nskip
      isave(6) = head
      isave(7) = col
      isave(8) = itail
      isave(9) = iter
      isave(10) = iupdat
      isave(12) = nseg
      isave(13) = nfgv
      isave(14) = info
      isave(15) = ifun
      isave(16) = iword
      isave(17) = nfree
      isave(18) = nact
      isave(19) = ileave
      isave(20) = nenter

      dsave(1) = theta
      dsave(2) = fold
      dsave(3) = tol
      dsave(4) = dnorm
      dsave(5) = epsmch
      dsave(6) = cpu1
      dsave(7) = cachyt
      dsave(8) = sbtime
      dsave(9) = lnscht
      dsave(10) = time1
      dsave(11) = gd
      dsave(12) = stpmx
      dsave(13) = sbgnrm
      dsave(14) = stp
      dsave(15) = gdold
      dsave(16) = dtd

200   Format (/, /, 'ITERATION ', I5)
210   Format (/, 'At iterate', I5, 4X, 'f= ', 1P, D12.5, 4X, '|proj g|= ', 1P, &
        D12.5)
220   Format (2(1X,I4), 5X, '-', 5X, '-', 3X, '-', 5X, '-', 5X, '-', 8X, '-', &
        3X, 1P, 2(1X,D10.3))
230   Format ('  ys=', 1P, E10.3, '  -gs=', 1P, E10.3, ' BFGS update SKIPPED')
240   Format (/, ' Singular triangular system detected;', /, &
        '   refresh the lbfgs memory and restart the iteration.')
250   Format (/, &
        ' Nonpositive definiteness in Cholesky factorization in formk;', /, &
        '   refresh the lbfgs memory and restart the iteration.')
260   Format (/, &
        ' Nonpositive definiteness in Cholesky factorization in formt;', /, &
        '   refresh the lbfgs memory and restart the iteration.')
270   Format (/, ' Bad direction in the line search;', /, &
        '   refresh the lbfgs memory and restart the iteration.')

      Return

    End Subroutine

!======================= The end of mainlb =============================

    Subroutine PREC(active)(n, l, u, nbd, x, iwhere, iprint, prjctd, cnstnd, boxed)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Logical :: prjctd, cnstnd, boxed
      Integer :: n, iprint, nbd(n), iwhere(n)
      Real (Kind=wp) :: x(n), l(n), u(n)

!     ************
!
!     Subroutine active
!
!     This subroutine initializes iwhere and projects the initial x to
!       the feasible set if necessary.
!
!     iwhere is an integer array of dimension n.
!       On entry iwhere is unspecified.
!       On exit iwhere(i)=-1  if x(i) has no bounds
!                         3   if l(i)=u(i)
!                         0   otherwise.
!       In cauchy, iwhere is given finer gradations.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: nbdd, i
      Real (Kind=wp) :: zero
      Parameter (zero=0.0E0_wp)

!     Initialize nbdd, prjctd, cnstnd and boxed.

      nbdd = 0
      prjctd = .False.
      cnstnd = .False.
      boxed = .True.

!     Project the initial x to the easible set if necessary.

      Do i = 1, n
        If (nbd(i)>0) Then
          If (nbd(i)<=2 .And. x(i)<=l(i)) Then
            If (x(i)<l(i)) Then
              prjctd = .True.
              x(i) = l(i)
            End If
            nbdd = nbdd + 1
          Else If (nbd(i)>=2 .And. x(i)>=u(i)) Then
            If (x(i)>u(i)) Then
              prjctd = .True.
              x(i) = u(i)
            End If
            nbdd = nbdd + 1
          End If
        End If
      End Do

!     Initialize iwhere and assign values to cnstnd and boxed.

      Do i = 1, n
        If (nbd(i)/=2) boxed = .False.
        If (nbd(i)==0) Then
!                                this variable is always free
          iwhere(i) = -1

!           otherwise set x(i)=mid(x(i), u(i), l(i)).
        Else
          cnstnd = .True.
          If (nbd(i)==2 .And. u(i)-l(i)<=zero) Then
!                   this variable is always fixed
            iwhere(i) = 3
          Else
            iwhere(i) = 0
          End If
        End If
      End Do

      If (iprint>=0) Then
        If (prjctd) Write (6, *) &
          'The initial X is infeasible.  Restart with its projection.'
        If (.Not. cnstnd) Write (6, *) 'This problem is unconstrained.'
      End If

      If (iprint>0) Write (6, 100) nbdd

100   Format (/, 'At X0 ', I9, ' variables are exactly at the bounds')

      Return

    End Subroutine

!======================= The end of active =============================

    Subroutine PREC(bmv)(m, sy, wt, col, v, p, info)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Integer :: m, col, info
      Real (Kind=wp) :: sy(m, m), wt(m, m), v(2*col), p(2*col)

!     ************
!
!     Subroutine bmv
!
!     This subroutine computes the product of the 2m x 2m middle matrix
!       in the compact L-BFGS formula of B and a 2m vector v;
!       it returns the product in p.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     sy is a double precision array of dimension m x m.
!       On entry sy specifies the matrix S'Y.
!       On exit sy is unchanged.
!
!     wt is a double precision array of dimension m x m.
!       On entry wt specifies the upper triangular matrix J' which is
!         the Cholesky factor of (thetaS'S+LD^(-1)L').
!       On exit wt is unchanged.
!
!     col is an integer variable.
!       On entry col specifies the number of s-vectors (or y-vectors)
!         stored in the compact L-BFGS formula.
!       On exit col is unchanged.
!
!     v is a double precision array of dimension 2col.
!       On entry v specifies vector v.
!       On exit v is unchanged.
!
!     p is a double precision array of dimension 2col.
!       On entry p is unspecified.
!       On exit p is the product Mv.
!
!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return when the system
!                                to be solved by dtrsl is singular.
!
!     Subprograms called:
!
!       Linpack ... dtrsl.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i, k, i2
      Real (Kind=wp) :: sum

      If (col==0) Return

!     PART I: solve [  D^(1/2)      O ] [ p1 ] = [ v1 ]
!                   [ -L*D^(-1/2)   J ] [ p2 ]   [ v2 ].

!       solve Jp2=v2+LD^(-1)v1.
      p(col+1) = v(col+1)
      Do i = 2, col
        i2 = col + i
        sum = 0.0E0_wp
        Do k = 1, i - 1
          sum = sum + sy(i, k)*v(k)/sy(k, k)
        End Do
        p(i2) = v(i2) + sum
      End Do
!     Solve the triangular system
      Call PREC(trsl)(wt, m, col, p(col+1), 11, info)
      If (info/=0) Return

!       solve D^(1/2)p1=v1.
      Do i = 1, col
        p(i) = v(i)/sqrt(sy(i,i))
      End Do

!     PART II: solve [ -D^(1/2)   D^(-1/2)*L'  ] [ p1 ] = [ p1 ]
!                    [  0         J'           ] [ p2 ]   [ p2 ].

!       solve J^Tp2=p2.
      Call PREC(trsl)(wt, m, col, p(col+1), 01, info)
      If (info/=0) Return

!       compute p1=-D^(-1/2)(p1-D^(-1/2)L'p2)
!                 =-D^(-1/2)p1+D^(-1)L'p2.
      Do i = 1, col
        p(i) = -p(i)/sqrt(sy(i,i))
      End Do
      Do i = 1, col
        sum = 0.E0_wp
        Do k = i + 1, col
          sum = sum + sy(k, i)*p(col+k)/sy(i, i)
        End Do
        p(i) = p(i) + sum
      End Do

      Return

    End Subroutine

!======================== The end of bmv ===============================

    Subroutine PREC(cauchy)(n, x, l, u, nbd, g, iorder, iwhere, t, d, xcp, m, wy, &
      ws, sy, wt, theta, col, head, p, c, wbp, v, nseg, iprint, sbgnrm, info, &
      epsmch)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif
      Implicit None
      Integer :: n, m, head, col, nseg, iprint, info, nbd(n), iorder(n), &
        iwhere(n)
      Real (Kind=wp) :: theta, epsmch, x(n), l(n), u(n), g(n), t(n), d(n), &
        xcp(n), wy(n, col), ws(n, col), sy(m, m), wt(m, m), p(2*m), c(2*m), &
        wbp(2*m), v(2*m)

!     ************
!
!     Subroutine cauchy
!
!     For given x, l, u, g (with sbgnrm > 0), and a limited memory
!       BFGS matrix B defined in terms of matrices WY, WS, WT, and
!       scalars head, col, and theta, this subroutine computes the
!       generalized Cauchy point (GCP), defined as the first local
!       minimizer of the quadratic
!
!                  Q(x + s) = g's + 1/2 s'Bs
!
!       along the projected gradient direction P(x-tg,l,u).
!       The routine returns the GCP in xcp.
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x is the starting point for the GCP computation.
!       On exit x is unchanged.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.
!
!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     g is a double precision array of dimension n.
!       On entry g is the gradient of f(x).  g must be a nonzero vector.
!       On exit g is unchanged.
!
!     iorder is an integer working array of dimension n.
!       iorder will be used to store the breakpoints in the piecewise
!       linear path and free variables encountered. On exit,
!         iorder(1),...,iorder(nleft) are indices of breakpoints
!                                which have not been encountered;
!         iorder(nleft+1),...,iorder(nbreak) are indices of
!                                     encountered breakpoints; and
!         iorder(nfree),...,iorder(n) are indices of variables which
!                 have no bound constraits along the search direction.
!
!     iwhere is an integer array of dimension n.
!       On entry iwhere indicates only the permanently fixed (iwhere=3)
!       or free (iwhere= -1) components of x.
!       On exit iwhere records the status of the current x variables.
!       iwhere(i)=-3  if x(i) is free and has bounds, but is not moved
!                 0   if x(i) is free and has bounds, and is moved
!                 1   if x(i) is fixed at l(i), and l(i) .ne. u(i)
!                 2   if x(i) is fixed at u(i), and u(i) .ne. l(i)
!                 3   if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
!                 -1  if x(i) is always free, i.e., it has no bounds.
!
!     t is a double precision working array of dimension n.
!       t will be used to store the break points.
!
!     d is a double precision array of dimension n used to store
!       the Cauchy direction P(x-tg)-x.
!
!     xcp is a double precision array of dimension n used to return the
!       GCP on exit.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     ws, wy, sy, and wt are double precision arrays.
!       On entry they store information that defines the
!                             limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         sy(m,m) stores S'Y;
!         wt(m,m) stores the
!                 Cholesky factorization of (theta*S'S+LD^(-1)L').
!       On exit these arrays are unchanged.
!
!     theta is a double precision variable.
!       On entry theta is the scaling factor specifying B_0 = theta I.
!       On exit theta is unchanged.
!
!     col is an integer variable.
!       On entry col is the actual number of variable metric
!         corrections stored so far.
!       On exit col is unchanged.
!
!     head is an integer variable.
!       On entry head is the location of the first s-vector (or y-vector)
!         in S (or Y).
!       On exit col is unchanged.
!
!     p is a double precision working array of dimension 2m.
!       p will be used to store the vector p = W^(T)d.
!
!     c is a double precision working array of dimension 2m.
!       c will be used to store the vector c = W^(T)(xcp-x).
!
!     wbp is a double precision working array of dimension 2m.
!       wbp will be used to store the row of W corresponding
!         to a breakpoint.
!
!     v is a double precision working array of dimension 2m.
!
!     nseg is an integer variable.
!       On exit nseg records the number of quadratic segments explored
!         in searching for the GCP.
!
!     sg and yg are double precision arrays of dimension m.
!       On entry sg  and yg store S'g and Y'g correspondingly.
!       On exit they are unchanged.
!
!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     sbgnrm is a double precision variable.
!       On entry sbgnrm is the norm of the projected gradient at x.
!       On exit sbgnrm is unchanged.
!
!     info is an integer variable.
!       On entry info is 0.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return when the the system
!                              used in routine bmv is singular.
!
!     Subprograms called:
!
!       L-BFGS-B Library ... hpsolb, bmv.
!
!       Linpack ... dscal dcopy, daxpy.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN
!       Subroutines for Large Scale Bound Constrained Optimization''
!       Tech. Report, NAM-11, EECS Department, Northwestern University,
!       1994.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Logical :: xlower, xupper, bnded
      Integer :: i, j, col2, nfree, nbreak, pointr, ibp, nleft, ibkmin, iter
      Real (Kind=wp) :: f1, f2, dt, dtm, tsum, dibp, zibp, dibp2, bkmin, tu, &
        tl, wmc, wmp, wmw, PREC(dot), tj, tj0, neggi, sbgnrm, f2_org
      Real (Kind=wp) :: one, zero
      Parameter (one=1.0E0_wp, zero=0.0E0_wp)

!     Check the status of the variables, reset iwhere(i) if necessary;
!       compute the Cauchy direction d and the breakpoints t; initialize
!       the derivative f1 and the vector p = W'd (for theta = 1).

      If (sbgnrm<=zero) Then
        If (iprint>=0) Write (6, *) 'Subgnorm = 0.  GCP = X.'
        Call PREC(copy)(n, x, 1, xcp, 1)
        Return
      End If
      bnded = .True.
      nfree = n + 1
      nbreak = 0
      ibkmin = 0
      bkmin = zero
      col2 = 2*col
      f1 = zero
      If (iprint>=99) Write (6, 150)

!     We set p to zero and build it up as we determine d.

      Do i = 1, col2
        p(i) = zero
      End Do

!     In the following loop we determine for each variable its bound
!        status and its breakpoint, and update p accordingly.
!        Smallest breakpoint is identified.

      Do i = 1, n
        neggi = -g(i)
        If (iwhere(i)/=3 .And. iwhere(i)/=-1) Then
!             if x(i) is not a constant and has bounds,
!             compute the difference between x(i) and its bounds.
          If (nbd(i)<=2) tl = x(i) - l(i)
          If (nbd(i)>=2) tu = u(i) - x(i)

!           If a variable is close enough to a bound
!             we treat it as at bound.
          xlower = nbd(i) <= 2 .And. tl <= zero
          xupper = nbd(i) >= 2 .And. tu <= zero

!              reset iwhere(i).
          iwhere(i) = 0
          If (xlower) Then
            If (neggi<=zero) iwhere(i) = 1
          Else If (xupper) Then
            If (neggi>=zero) iwhere(i) = 2
          Else
            If (abs(neggi)<=zero) iwhere(i) = -3
          End If
        End If
        pointr = head
        If (iwhere(i)/=0 .And. iwhere(i)/=-1) Then
          d(i) = zero
        Else
          d(i) = neggi
          f1 = f1 - neggi*neggi
!             calculate p := p - W'e_i* (g_i).
          Do j = 1, col
            p(j) = p(j) + wy(i, pointr)*neggi
            p(col+j) = p(col+j) + ws(i, pointr)*neggi
            pointr = mod(pointr, m) + 1
          End Do
          If (nbd(i)<=2 .And. nbd(i)/=0 .And. neggi<zero) Then
!                                 x(i) + d(i) is bounded; compute t(i).
            nbreak = nbreak + 1
            iorder(nbreak) = i
            t(nbreak) = tl/(-neggi)
            If (nbreak==1 .Or. t(nbreak)<bkmin) Then
              bkmin = t(nbreak)
              ibkmin = nbreak
            End If
          Else If (nbd(i)>=2 .And. neggi>zero) Then
!                                 x(i) + d(i) is bounded; compute t(i).
            nbreak = nbreak + 1
            iorder(nbreak) = i
            t(nbreak) = tu/neggi
            If (nbreak==1 .Or. t(nbreak)<bkmin) Then
              bkmin = t(nbreak)
              ibkmin = nbreak
            End If
          Else
!                x(i) + d(i) is not bounded.
            nfree = nfree - 1
            iorder(nfree) = i
            If (abs(neggi)>zero) bnded = .False.
          End If
        End If
      End Do

!     The indices of the nonzero components of d are now stored
!       in iorder(1),...,iorder(nbreak) and iorder(nfree),...,iorder(n).
!       The smallest of the nbreak breakpoints is in t(ibkmin)=bkmin.

      If (theta/=one) Then
!                   complete the initialization of p for theta not= one.
        Call PREC(scal)(col, theta, p(col+1), 1)
      End If

!     Initialize GCP xcp = x.

      Call PREC(copy)(n, x, 1, xcp, 1)

      If (nbreak==0 .And. nfree==n+1) Then
!                  is a zero vector, return with the initial xcp as GCP.
        If (iprint>100) Write (6, 130)(xcp(i), i=1, n)
        Return
      End If

!     Initialize c = W'(xcp - x) = 0.

      Do j = 1, col2
        c(j) = zero
      End Do

!     Initialize derivative f2.

      f2 = -theta*f1
      f2_org = f2
      If (col>0) Then
        Call PREC(bmv)(m, sy, wt, col, p, v, info)
        If (info/=0) Return
        f2 = f2 - PREC(dot)(col2, v, 1, p, 1)
      End If
      dtm = -f1/f2
      tsum = zero
      nseg = 1
      If (iprint>=99) Write (6, *) 'There are ', nbreak, '  breakpoints '

!     If there are no breakpoints, locate the GCP and return.

      If (nbreak==0) Go To 110

      nleft = nbreak
      iter = 1


      tj = zero

!------------------- the beginning of the loop -------------------------

100   Continue

!     Find the next smallest breakpoint;
!       compute dt = t(nleft) - t(nleft + 1).

      tj0 = tj
      If (iter==1) Then
!         Since we already have the smallest breakpoint we need not do
!         heapsort yet. Often only one breakpoint is used and the
!         cost of heapsort is avoided.
        tj = bkmin
        ibp = iorder(ibkmin)
      Else
        If (iter==2) Then
!             Replace the already used smallest breakpoint with the
!             breakpoint numbered nbreak > nlast, before heapsort call.
          If (ibkmin/=nbreak) Then
            t(ibkmin) = t(nbreak)
            iorder(ibkmin) = iorder(nbreak)
          End If
!        Update heap structure of breakpoints
!           (if iter=2, initialize heap).
        End If
        Call PREC(hpsolb)(nleft, t, iorder, iter-2)
        tj = t(nleft)
        ibp = iorder(nleft)
      End If

      dt = tj - tj0

      If (dt/=zero .And. iprint>=100) Then
        Write (6, 170) nseg, f1, f2
        Write (6, 180) dt
        Write (6, 190) dtm
      End If

!     If a minimizer is within this interval, locate the GCP and return.

      If (dtm<dt) Go To 110

!     Otherwise fix one variable and
!       reset the corresponding component of d to zero.

      tsum = tsum + dt
      nleft = nleft - 1
      iter = iter + 1
      dibp = d(ibp)
      d(ibp) = zero
      If (dibp>zero) Then
        zibp = u(ibp) - x(ibp)
        xcp(ibp) = u(ibp)
        iwhere(ibp) = 2
      Else
        zibp = l(ibp) - x(ibp)
        xcp(ibp) = l(ibp)
        iwhere(ibp) = 1
      End If
      If (iprint>=100) Write (6, *) 'Variable  ', ibp, '  is fixed.'
      If (nleft==0 .And. nbreak==n) Then
!                                             all n variables are fixed,
!                                                return with xcp as GCP.
        dtm = dt
        Go To 120
      End If

!     Update the derivative information.

      nseg = nseg + 1
      dibp2 = dibp**2

!     Update f1 and f2.

!        temporarily set f1 and f2 for col=0.
      f1 = f1 + dt*f2 + dibp2 - theta*dibp*zibp
      f2 = f2 - theta*dibp2

      If (col>0) Then
!                          update c = c + dt*p.
        Call PREC(axpy)(col2, dt, p, 1, c, 1)

!           choose wbp,
!           the row of W corresponding to the breakpoint encountered.
        pointr = head
        Do j = 1, col
          wbp(j) = wy(ibp, pointr)
          wbp(col+j) = theta*ws(ibp, pointr)
          pointr = mod(pointr, m) + 1
        End Do

!           compute (wbp)Mc, (wbp)Mp, and (wbp)M(wbp)'.
        Call PREC(bmv)(m, sy, wt, col, wbp, v, info)
        If (info/=0) Return
        wmc = PREC(dot)(col2, c, 1, v, 1)
        wmp = PREC(dot)(col2, p, 1, v, 1)
        wmw = PREC(dot)(col2, wbp, 1, v, 1)

!           update p = p - dibp*wbp.
        Call PREC(axpy)(col2, -dibp, wbp, 1, p, 1)

!           complete updating f1 and f2 while col > 0.
        f1 = f1 + dibp*wmc
        f2 = f2 + 2.0E0_wp*dibp*wmp - dibp2*wmw
      End If

      f2 = max(epsmch*f2_org, f2)
      If (nleft>0) Then
        dtm = -f1/f2
        Go To 100
!                 to repeat the loop for unsearched intervals.
      Else If (bnded) Then
        f1 = zero
        f2 = zero
        dtm = zero
      Else
        dtm = -f1/f2
      End If

!------------------- the end of the loop -------------------------------

110   Continue
      If (iprint>=99) Then
        Write (6, *)
        Write (6, *) 'GCP found in this segment'
        Write (6, 160) nseg, f1, f2
        Write (6, 190) dtm
      End If
      If (dtm<=zero) dtm = zero
      tsum = tsum + dtm

!     Move free variables (i.e., the ones w/o breakpoints) and
!       the variables whose breakpoints haven't been reached.

      Call PREC(axpy)(n, tsum, d, 1, xcp, 1)

120   Continue

!     Update c = c + dtm*p = W'(x^c - x)
!       which will be used in computing r = Z'(B(x^c - x) + g).

      If (col>0) Call PREC(axpy)(col2, dtm, p, 1, c, 1)
      If (iprint>100) Write (6, 130)(xcp(i), i=1, n)
      If (iprint>=99) Write (6, 140)

130   Format ('Cauchy X =  ', /, (4X,1P,6(1X,D11.4)))
140   Format (/, '---------------- exit CAUCHY----------------------', /)
150   Format (/, '---------------- CAUCHY entered-------------------')
160   Format ('Piece    ', I3, ' --f1, f2 at start point ', 1P, 2(1X,D11.4))
170   Format (/, 'Piece    ', I3, ' --f1, f2 at start point ', 1P, &
        2(1X,D11.4))
180   Format ('Distance to the next break point =  ', 1P, D11.4)
190   Format ('Distance to the stationary point =  ', 1P, D11.4)

      Return

    End Subroutine

!====================== The end of cauchy ==============================

    Subroutine PREC(cmprlb)(n, m, x, g, ws, wy, sy, wt, z, r, wa, index, theta, col, &
      head, nfree, cnstnd, info)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Logical :: cnstnd
      Integer :: n, m, col, head, nfree, info, index(n)
      Real (Kind=wp) :: theta, x(n), g(n), z(n), r(n), wa(4*m), ws(n, m), &
        wy(n, m), sy(m, m), wt(m, m)

!     ************
!
!     Subroutine cmprlb
!
!       This subroutine computes r=-Z'B(xcp-xk)-Z'g by using
!         wa(2m+1)=W'(xcp-x) from subroutine cauchy.
!
!     Subprograms called:
!
!       L-BFGS-B Library ... bmv.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i, j, k, pointr
      Real (Kind=wp) :: a1, a2

      If (.Not. cnstnd .And. col>0) Then
        Do i = 1, n
          r(i) = -g(i)
        End Do
      Else
        Do i = 1, nfree
          k = index(i)
          r(i) = -theta*(z(k)-x(k)) - g(k)
        End Do
        Call PREC(bmv)(m, sy, wt, col, wa(2*m+1), wa(1), info)
        If (info/=0) Then
          info = -8
          Return
        End If
        pointr = head
        Do j = 1, col
          a1 = wa(j)
          a2 = theta*wa(col+j)
          Do i = 1, nfree
            k = index(i)
            r(i) = r(i) + wy(k, pointr)*a1 + ws(k, pointr)*a2
          End Do
          pointr = mod(pointr, m) + 1
        End Do
      End If

      Return

    End Subroutine

!======================= The end of cmprlb =============================

    Subroutine PREC(errclb)(n, m, factr, l, u, nbd, task, info, k)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Character (60) :: task
      Integer :: n, m, info, k, nbd(n)
      Real (Kind=wp) :: factr, l(n), u(n)

!     ************
!
!     Subroutine errclb
!
!     This subroutine checks the validity of the input data.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i
      Real (Kind=wp) :: one, zero
      Parameter (one=1.0E0_wp, zero=0.0E0_wp)

!     Check the input arguments for errors.

      If (n<=0) task = 'ERROR: N .LE. 0'
      If (m<=0) task = 'ERROR: M .LE. 0'
      If (factr<zero) task = 'ERROR: FACTR .LT. 0'

!     Check the validity of the arrays nbd(i), u(i), and l(i).

      Do i = 1, n
        If (nbd(i)<0 .Or. nbd(i)>3) Then
!                                                   return
          task = 'ERROR: INVALID NBD'
          info = -6
          k = i
        End If
        If (nbd(i)==2) Then
          If (l(i)>u(i)) Then
!                                    return
            task = 'ERROR: NO FEASIBLE SOLUTION'
            info = -7
            k = i
          End If
        End If
      End Do

      Return

    End Subroutine

!======================= The end of errclb =============================

    Subroutine PREC(formk)(n, nsub, ind, nenter, ileave, indx2, iupdat, updatd, wn, &
      wn1, m, ws, wy, sy, theta, col, head, info)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Integer :: n, nsub, m, col, head, nenter, ileave, iupdat, info, ind(n), &
        indx2(n)
      Real (Kind=wp) :: theta, wn(2*m, 2*m), wn1(2*m, 2*m), ws(n, m), &
        wy(n, m), sy(m, m)
      Logical :: updatd

!     ************
!
!     Subroutine formk
!
!     This subroutine forms  the LEL^T factorization of the indefinite
!
!       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!                                                    where E = [-I  0]
!                                                              [ 0  I]
!     The matrix K can be shown to be equal to the matrix M^[-1]N
!       occurring in section 5.1 of [1], as well as to the matrix
!       Mbar^[-1] Nbar in section 5.3.
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     nsub is an integer variable
!       On entry nsub is the number of subspace variables in free set.
!       On exit nsub is not changed.
!
!     ind is an integer array of dimension nsub.
!       On entry ind specifies the indices of subspace variables.
!       On exit ind is unchanged.
!
!     nenter is an integer variable.
!       On entry nenter is the number of variables entering the
!         free set.
!       On exit nenter is unchanged.
!
!     ileave is an integer variable.
!       On entry indx2(ileave),...,indx2(n) are the variables leaving
!         the free set.
!       On exit ileave is unchanged.
!
!     indx2 is an integer array of dimension n.
!       On entry indx2(1),...,indx2(nenter) are the variables entering
!         the free set, while indx2(ileave),...,indx2(n) are the
!         variables leaving the free set.
!       On exit indx2 is unchanged.
!
!     iupdat is an integer variable.
!       On entry iupdat is the total number of BFGS updates made so far.
!       On exit iupdat is unchanged.
!
!     updatd is a logical variable.
!       On entry 'updatd' is true if the L-BFGS matrix is updatd.
!       On exit 'updatd' is unchanged.
!
!     wn is a double precision array of dimension 2m x 2m.
!       On entry wn is unspecified.
!       On exit the upper triangle of wn stores the LEL^T factorization
!         of the 2*col x 2*col indefinite matrix
!                     [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!
!     wn1 is a double precision array of dimension 2m x 2m.
!       On entry wn1 stores the lower triangular part of
!                     [Y' ZZ'Y   L_a'+R_z']
!                     [L_a+R_z   S'AA'S   ]
!         in the previous iteration.
!       On exit wn1 stores the corresponding updated matrices.
!       The purpose of wn1 is just to store these inner products
!       so they can be easily updated and inserted into wn.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     ws, wy, sy, and wtyy are double precision arrays;
!     theta is a double precision variable;
!     col is an integer variable;
!     head is an integer variable.
!       On entry they store the information defining the
!                                          limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         sy(m,m) stores S'Y;
!         wtyy(m,m) stores the Cholesky factorization
!                                   of (theta*S'S+LD^(-1)L')
!         theta is the scaling factor specifying B_0 = theta I;
!         col is the number of variable metric corrections stored;
!         head is the location of the 1st s- (or y-) vector in S (or Y).
!       On exit they are unchanged.
!
!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info =  0 for normal return;
!                    = -1 when the 1st Cholesky factorization failed;
!                    = -2 when the 2st Cholesky factorization failed.
!
!     Subprograms called:
!
!       Linpack ... dcopy, dpofa, dtrsl.
!
!
!     References:
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
!       limited memory FORTRAN code for solving bound constrained
!       optimization problems'', Tech. Report, NAM-11, EECS Department,
!       Northwestern University, 1994.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: m2, ipntr, jpntr, iy, is, jy, js, is1, js1, k1, i, k, col2, &
        pbegin, pend, dbegin, dend, upcl
      Real (Kind=wp) :: PREC(dot), temp1, temp2, temp3, temp4
      Real (Kind=wp) :: one, zero
      Parameter (one=1.0E0_wp, zero=0.0E0_wp)

!     Form the lower triangular part of
!               WN1 = [Y' ZZ'Y   L_a'+R_z']
!                     [L_a+R_z   S'AA'S   ]
!        where L_a is the strictly lower triangular part of S'AA'Y
!              R_z is the upper triangular part of S'ZZ'Y.

      If (updatd) Then
        If (iupdat>m) Then
!                                 shift old part of WN1.
          Do jy = 1, m - 1
            js = m + jy
            Call PREC(copy)(m-jy, wn1(jy+1,jy+1), 1, wn1(jy,jy), 1)
            Call PREC(copy)(m-jy, wn1(js+1,js+1), 1, wn1(js,js), 1)
            Call PREC(copy)(m-1, wn1(m+2,jy+1), 1, wn1(m+1,jy), 1)
          End Do
        End If

!          put new rows in blocks (1,1), (2,1) and (2,2).
        pbegin = 1
        pend = nsub
        dbegin = nsub + 1
        dend = n
        iy = col
        is = m + col
        ipntr = head + col - 1
        If (ipntr>m) ipntr = ipntr - m
        jpntr = head
        Do jy = 1, col
          js = m + jy
          temp1 = zero
          temp2 = zero
          temp3 = zero
!             compute element jy of row 'col' of Y'ZZ'Y
          Do k = pbegin, pend
            k1 = ind(k)
            temp1 = temp1 + wy(k1, ipntr)*wy(k1, jpntr)
          End Do
!             compute elements jy of row 'col' of L_a and S'AA'S
          Do k = dbegin, dend
            k1 = ind(k)
            temp2 = temp2 + ws(k1, ipntr)*ws(k1, jpntr)
            temp3 = temp3 + ws(k1, ipntr)*wy(k1, jpntr)
          End Do
          wn1(iy, jy) = temp1
          wn1(is, js) = temp2
          wn1(is, jy) = temp3
          jpntr = mod(jpntr, m) + 1
        End Do

!          put new column in block (2,1).
        jy = col
        jpntr = head + col - 1
        If (jpntr>m) jpntr = jpntr - m
        ipntr = head
        Do i = 1, col
          is = m + i
          temp3 = zero
!             compute element i of column 'col' of R_z
          Do k = pbegin, pend
            k1 = ind(k)
            temp3 = temp3 + ws(k1, ipntr)*wy(k1, jpntr)
          End Do
          ipntr = mod(ipntr, m) + 1
          wn1(is, jy) = temp3
        End Do
        upcl = col - 1
      Else
        upcl = col
      End If

!       modify the old parts in blocks (1,1) and (2,2) due to changes
!       in the set of free variables.
      ipntr = head
      Do iy = 1, upcl
        is = m + iy
        jpntr = head
        Do jy = 1, iy
          js = m + jy
          temp1 = zero
          temp2 = zero
          temp3 = zero
          temp4 = zero
          Do k = 1, nenter
            k1 = indx2(k)
            temp1 = temp1 + wy(k1, ipntr)*wy(k1, jpntr)
            temp2 = temp2 + ws(k1, ipntr)*ws(k1, jpntr)
          End Do
          Do k = ileave, n
            k1 = indx2(k)
            temp3 = temp3 + wy(k1, ipntr)*wy(k1, jpntr)
            temp4 = temp4 + ws(k1, ipntr)*ws(k1, jpntr)
          End Do
          wn1(iy, jy) = wn1(iy, jy) + temp1 - temp3
          wn1(is, js) = wn1(is, js) - temp2 + temp4
          jpntr = mod(jpntr, m) + 1
        End Do
        ipntr = mod(ipntr, m) + 1
      End Do

!       modify the old parts in block (2,1).
      ipntr = head
      Do is = m + 1, m + upcl
        jpntr = head
        Do jy = 1, upcl
          temp1 = zero
          temp3 = zero
          Do k = 1, nenter
            k1 = indx2(k)
            temp1 = temp1 + ws(k1, ipntr)*wy(k1, jpntr)
          End Do
          Do k = ileave, n
            k1 = indx2(k)
            temp3 = temp3 + ws(k1, ipntr)*wy(k1, jpntr)
          End Do
          If (is<=jy+m) Then
            wn1(is, jy) = wn1(is, jy) + temp1 - temp3
          Else
            wn1(is, jy) = wn1(is, jy) - temp1 + temp3
          End If
          jpntr = mod(jpntr, m) + 1
        End Do
        ipntr = mod(ipntr, m) + 1
      End Do

!     Form the upper triangle of WN = [D+Y' ZZ'Y/theta   -L_a'+R_z' ]
!                                     [-L_a +R_z        S'AA'S*theta]

      m2 = 2*m
      Do iy = 1, col
        is = col + iy
        is1 = m + iy
        Do jy = 1, iy
          js = col + jy
          js1 = m + jy
          wn(jy, iy) = wn1(iy, jy)/theta
          wn(js, is) = wn1(is1, js1)*theta
        End Do
        Do jy = 1, iy - 1
          wn(jy, is) = -wn1(is1, jy)
        End Do
        Do jy = iy, col
          wn(jy, is) = wn1(is1, jy)
        End Do
        wn(iy, iy) = wn(iy, iy) + sy(iy, iy)
      End Do

!     Form the upper triangle of WN= [  LL'            L^-1(-L_a'+R_z')]
!                                    [(-L_a +R_z)L'^-1   S'AA'S*theta  ]

!        first Cholesky factor (1,1) block of wn to get LL'
!                          with L' stored in the upper triangle of wn.
      Call PREC(pofa)(wn, m2, col, info)
      If (info/=0) Then
        info = -1
        Return
      End If
!        then form L^-1(-L_a'+R_z') in the (1,2) block.
      col2 = 2*col
      Do js = col + 1, col2
        Call PREC(trsl)(wn, m2, col, wn(1,js), 11, info)
      End Do

!     Form S'AA'S*theta + (L^-1(-L_a'+R_z'))'L^-1(-L_a'+R_z') in the
!        upper triangle of (2,2) block of wn.


      Do is = col + 1, col2
        Do js = is, col2
          wn(is, js) = wn(is, js) + PREC(dot)(col, wn(1,is), 1, wn(1,js), 1)
        End Do
      End Do

!     Cholesky factorization of (2,2) block of wn.

      Call PREC(pofa)(wn(col+1,col+1), m2, col, info)
      If (info/=0) Then
        info = -2
        Return
      End If

      Return

    End Subroutine

!======================= The end of formk ==============================

    Subroutine PREC(formt)(m, wt, sy, ss, col, theta, info)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Integer :: m, col, info
      Real (Kind=wp) :: theta, wt(m, m), sy(m, m), ss(m, m)

!     ************
!
!     Subroutine formt
!
!       This subroutine forms the upper half of the pos. def. and symm.
!         T = theta*SS + L*D^(-1)*L', stores T in the upper triangle
!         of the array wt, and performs the Cholesky factorization of T
!         to produce J*J', with J' stored in the upper triangle of wt.
!
!     Subprograms called:
!
!       Linpack ... dpofa.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i, j, k, k1
      Real (Kind=wp) :: ddum
      Real (Kind=wp) :: zero
      Parameter (zero=0.0E0_wp)


!     Form the upper half of  T = theta*SS + L*D^(-1)*L',
!        store T in the upper triangle of the array wt.

      Do j = 1, col
        wt(1, j) = theta*ss(1, j)
      End Do
      Do i = 2, col
        Do j = i, col
          k1 = min(i, j) - 1
          ddum = zero
          Do k = 1, k1
            ddum = ddum + sy(i, k)*sy(j, k)/sy(k, k)
          End Do
          wt(i, j) = ddum + theta*ss(i, j)
        End Do
      End Do

!     Cholesky factorize T to J*J' with
!        J' stored in the upper triangle of wt.

      Call PREC(pofa)(wt, m, col, info)
      If (info/=0) Then
        info = -3
      End If

      Return

    End Subroutine

!======================= The end of formt ==============================

    Subroutine PREC(freev)(n, nfree, index, nenter, ileave, indx2, iwhere, wrk, &
      updatd, cnstnd, iprint, iter)

      Integer :: n, nfree, nenter, ileave, iprint, iter, index(n), indx2(n), &
        iwhere(n)
      Logical :: wrk, updatd, cnstnd

!     ************
!
!     Subroutine freev
!
!     This subroutine counts the entering and leaving variables when
!       iter > 0, and finds the index set of free and active variables
!       at the GCP.
!
!     cnstnd is a logical variable indicating whether bounds are present
!
!     index is an integer array of dimension n
!       for i=1,...,nfree, index(i) are the indices of free variables
!       for i=nfree+1,...,n, index(i) are the indices of bound variables
!       On entry after the first iteration, index gives
!         the free variables at the previous iteration.
!       On exit it gives the free variables based on the determination
!         in cauchy using the array iwhere.
!
!     indx2 is an integer array of dimension n
!       On entry indx2 is unspecified.
!       On exit with iter>0, indx2 indicates which variables
!          have changed status since the previous iteration.
!       For i= 1,...,nenter, indx2(i) have changed from bound to free.
!       For i= ileave+1,...,n, indx2(i) have changed from free to bound.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: iact, i, k

      nenter = 0
      ileave = n + 1
      If (iter>0 .And. cnstnd) Then
!                           count the entering and leaving variables.
        Do i = 1, nfree
          k = index(i)

!            write(6,*) ' k  = index(i) ', k
!            write(6,*) ' index = ', i

          If (iwhere(k)>0) Then
            ileave = ileave - 1
            indx2(ileave) = k
            If (iprint>=100) Write (6, *) 'Variable ', k, &
              ' leaves the set of free variables'
          End If
        End Do
        Do i = 1 + nfree, n
          k = index(i)
          If (iwhere(k)<=0) Then
            nenter = nenter + 1
            indx2(nenter) = k
            If (iprint>=100) Write (6, *) 'Variable ', k, &
              ' enters the set of free variables'
          End If
        End Do
        If (iprint>=99) Write (6, *) n + 1 - ileave, ' variables leave; ', &
          nenter, ' variables enter'
      End If
      wrk = (ileave<n+1) .Or. (nenter>0) .Or. updatd

!     Find the index set of free and active variables at the GCP.

      nfree = 0
      iact = n + 1
      Do i = 1, n
        If (iwhere(i)<=0) Then
          nfree = nfree + 1
          index(nfree) = i
        Else
          iact = iact - 1
          index(iact) = i
        End If
      End Do
      If (iprint>=99) Write (6, *) nfree, ' variables are free at GCP ', &
        iter + 1

      Return

    End Subroutine

!======================= The end of freev ==============================

    Subroutine PREC(hpsolb)(n, t, iorder, iheap)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif
      Integer :: iheap, n, iorder(n)
      Real (Kind=wp) :: t(n)

!     ************
!
!     Subroutine hpsolb
!
!     This subroutine sorts out the least element of t, and puts the
!       remaining elements of t in a heap.
!
!     n is an integer variable.
!       On entry n is the dimension of the arrays t and iorder.
!       On exit n is unchanged.
!
!     t is a double precision array of dimension n.
!       On entry t stores the elements to be sorted,
!       On exit t(n) stores the least elements of t, and t(1) to t(n-1)
!         stores the remaining elements in the form of a heap.
!
!     iorder is an integer array of dimension n.
!       On entry iorder(i) is the index of t(i).
!       On exit iorder(i) is still the index of t(i), but iorder may be
!         permuted in accordance with t.
!
!     iheap is an integer variable specifying the task.
!       On entry iheap should be set as follows:
!         iheap .eq. 0 if t(1) to t(n) is not in the form of a heap,
!         iheap .ne. 0 if otherwise.
!       On exit iheap is unchanged.
!
!
!     References:
!       Algorithm 232 of CACM (J. W. J. Williams): HEAPSORT.
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!     ************

      Integer :: i, j, k, indxin, indxou
      Real (Kind=wp) :: ddum, out

      If (iheap==0) Then

!        Rearrange the elements t(1) to t(n) to form a heap.

        Do k = 2, n
          ddum = t(k)
          indxin = iorder(k)

!           Add ddum to the heap.
          i = k
100       Continue
          If (i>1) Then
            j = i/2
            If (ddum<t(j)) Then
              t(i) = t(j)
              iorder(i) = iorder(j)
              i = j
              Go To 100
            End If
          End If
          t(i) = ddum
          iorder(i) = indxin
        End Do
      End If

!     Assign to 'out' the value of t(1), the least member of the heap,
!        and rearrange the remaining members to form a heap as
!        elements 1 to n-1 of t.

      If (n>1) Then
        i = 1
        out = t(1)
        indxou = iorder(1)
        ddum = t(n)
        indxin = iorder(n)

!        Restore the heap
110     Continue
        j = i + i
        If (j<=n-1) Then
          If (t(j+1)<t(j)) j = j + 1
          If (t(j)<ddum) Then
            t(i) = t(j)
            iorder(i) = iorder(j)
            i = j
            Go To 110
          End If
        End If
        t(i) = ddum
        iorder(i) = indxin

!     Put the least member in t(n).

        t(n) = out
        iorder(n) = indxou
      End If

      Return

    End Subroutine

!====================== The end of hpsolb ==============================

    Subroutine PREC(lnsrlb)(n, l, u, nbd, x, f, fold, gd, gdold, g, d, r, t, z, stp, &
      dnorm, dtd, xstep, stpmx, iter, ifun, iback, nfgv, info, task, boxed, &
      cnstnd, csave, isave, dsave)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Character (60) :: task, csave
      Logical :: boxed, cnstnd
      Integer :: n, iter, ifun, iback, nfgv, info, nbd(n), isave(2)
      Real (Kind=wp) :: f, fold, gd, gdold, stp, dnorm, dtd, xstep, stpmx, &
        x(n), l(n), u(n), g(n), d(n), r(n), t(n), z(n), dsave(13)
!     **********
!
!     Subroutine lnsrlb
!
!     This subroutine calls subroutine dcsrch from the Minpack2 library
!       to perform the line search.  Subroutine dscrch is safeguarded so
!       that all trial points lie within the feasible region.
!
!     Subprograms called:
!
!       Minpack2 Library ... dcsrch.
!
!       Linpack ... dtrsl, ddot.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     **********

      Integer :: i
      Real (Kind=wp) :: PREC(dot), a1, a2
      Real (Kind=wp) :: one, zero, big
      Parameter (one=1.0E0_wp, zero=0.0E0_wp, big=1.0E+10_wp)
      Real (Kind=wp) :: ftol, gtol, xtol
      Parameter (ftol=1.0E-3_wp, gtol=0.9E0_wp, xtol=0.1E0_wp)
      csave = '' ! dcsrch makes a jump based on the task saved in csave
      ! Valgrind: Conditional jump or move depends on uninitialised value(s)
      If (task(1:5)=='FG_LN') Go To 100

      dtd = PREC(dot)(n, d, 1, d, 1)
      dnorm = sqrt(dtd)

!     Determine the maximum step length.

      stpmx = big
      If (cnstnd) Then
        If (iter==0) Then
          stpmx = one
        Else
          Do i = 1, n
            a1 = d(i)
            If (nbd(i)/=0) Then
              If (a1<zero .And. nbd(i)<=2) Then
                a2 = l(i) - x(i)
                If (a2>=zero) Then
                  stpmx = zero
                Else If (a1*stpmx<a2) Then
                  stpmx = a2/a1
                End If
              Else If (a1>zero .And. nbd(i)>=2) Then
                a2 = u(i) - x(i)
                If (a2<=zero) Then
                  stpmx = zero
                Else If (a1*stpmx>a2) Then
                  stpmx = a2/a1
                End If
              End If
            End If
          End Do
        End If
      End If

      If (iter==0 .And. .Not. boxed) Then
        stp = min(one/dnorm, stpmx)
      Else
        stp = one
      End If

      Call PREC(copy)(n, x, 1, t, 1)
      Call PREC(copy)(n, g, 1, r, 1)
      fold = f
      ifun = 0
      iback = 0
      csave = 'START'
100   Continue
      gd = PREC(dot)(n, g, 1, d, 1)
      If (ifun==0) Then
        gdold = gd
        If (gd>=zero) Then
!                               the directional derivative >=0.
!                               Line search is impossible.
          Write (6, *) ' ascent direction in projection gd = ', gd
          info = -4
          Return
        End If
      End If

      Call PREC(csrch)(f, gd, stp, ftol, gtol, xtol, zero, stpmx, csave, isave, &
        dsave)

      xstep = stp*dnorm
      If (csave(1:4)/='CONV' .And. csave(1:4)/='WARN') Then
        task = 'FG_LNSRCH'
        ifun = ifun + 1
        nfgv = nfgv + 1
        iback = ifun - 1
        If (stp==one) Then
          Call PREC(copy)(n, z, 1, x, 1)
        Else
          Do i = 1, n
            x(i) = stp*d(i) + t(i)
          End Do
        End If
      Else
        task = 'NEW_X'
      End If

      Return

    End Subroutine

!======================= The end of lnsrlb =============================

    Subroutine PREC(matupd)(n, m, ws, wy, sy, ss, d, r, itail, iupdat, col, head, &
      theta, rr, dr, stp, dtd)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Integer :: n, m, itail, iupdat, col, head
      Real (Kind=wp) :: theta, rr, dr, stp, dtd, d(n), r(n), ws(n, m), &
        wy(n, m), sy(m, m), ss(m, m)

!     ************
!
!     Subroutine matupd
!
!       This subroutine updates matrices WS and WY, and forms the
!         middle matrix in B.
!
!     Subprograms called:
!
!       Linpack ... dcopy, ddot.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: j, pointr
      Real (Kind=wp) :: PREC(dot)
      Real (Kind=wp) :: one
      Parameter (one=1.0E0_wp)

!     Set pointers for matrices WS and WY.

      If (iupdat<=m) Then
        col = iupdat
        itail = mod(head+iupdat-2, m) + 1
      Else
        itail = mod(itail, m) + 1
        head = mod(head, m) + 1
      End If

!     Update matrices WS and WY.

      Call PREC(copy)(n, d, 1, ws(1,itail), 1)
      Call PREC(copy)(n, r, 1, wy(1,itail), 1)

!     Set theta=yy/ys.

      theta = rr/dr

!     Form the middle matrix in B.

!        update the upper triangle of SS,
!                                         and the lower triangle of SY:
      If (iupdat>m) Then
!                              move old information
        Do j = 1, col - 1
          Call PREC(copy)(j, ss(2,j+1), 1, ss(1,j), 1)
          Call PREC(copy)(col-j, sy(j+1,j+1), 1, sy(j,j), 1)
        End Do
      End If
!        add new information: the last row of SY
!                                             and the last column of SS:
      pointr = head
      Do j = 1, col - 1
        sy(col, j) = PREC(dot)(n, d, 1, wy(1,pointr), 1)
        ss(j, col) = PREC(dot)(n, ws(1,pointr), 1, d, 1)
        pointr = mod(pointr, m) + 1
      End Do
      If (stp==one) Then
        ss(col, col) = dtd
      Else
        ss(col, col) = stp*stp*dtd
      End If
      sy(col, col) = dr

      Return

    End Subroutine

!======================= The end of matupd =============================

    Subroutine PREC(prn1lb)(n, m, l, u, x, iprint, itfile, epsmch)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Integer :: n, m, iprint, itfile
      Real (Kind=wp) :: epsmch, x(n), l(n), u(n)

!     ************
!
!     Subroutine prn1lb
!
!     This subroutine prints the input data, initial point, upper and
!       lower bounds of each variable, machine precision, as well as
!       the headings of the output.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i

      If (iprint>=0) Then
        Write (6, 120) epsmch
        Write (6, *) 'N = ', n, '    M = ', m
        If (iprint>=1 .And. itfile/=0) Then
          Write (itfile, 110) epsmch
          Write (itfile, *) 'N = ', n, '    M = ', m
          Write (itfile, 130)
          If (iprint>100) Then
            Write (6, 100) 'L =', (l(i), i=1, n)
            Write (6, 100) 'X0 =', (x(i), i=1, n)
            Write (6, 100) 'U =', (u(i), i=1, n)
          End If
        End If
      End If

100   Format (/, A4, 1P, 6(1X,D11.4), /, (4X,1P,6(1X,D11.4)))
110   Format ('RUNNING THE L-BFGS-B CODE', /, /, 'it    = iteration number', &
        /, 'nf    = number of function evaluations', /, &
        'nseg  = number of segments explored during the Cauchy search', /, &
        'nact  = number of active bounds at the generalized Cauchy point', /, &
        'sub   = manner in which the subspace minimization terminated:', /, &
        '        con = converged, bnd = a bound was reached', /, &
        'itls  = number of iterations performed in the line search', /, &
        'stepl = step length used', /, &
        'tstep = norm of the displacement (total step)', /, &
        'projg = norm of the projected gradient', /, 'f     = function value', &
        /, /, '           * * *', /, /, 'Machine precision =', 1P, D10.3)
120   Format ('RUNNING THE L-BFGS-B CODE', /, /, '           * * *', /, /, &
        'Machine precision =', 1P, D10.3)
130   Format (/, 3X, 'it', 3X, 'nf', 2X, 'nseg', 2X, 'nact', 2X, 'sub', 2X, &
        'itls', 2X, 'stepl', 4X, 'tstep', 5X, 'projg', 8X, 'f')

      Return

    End Subroutine

!======================= The end of prn1lb =============================

    Subroutine PREC(prn2lb)(n, x, f, g, iprint, itfile, iter, nfgv, nact, sbgnrm, &
      nseg, word, iword, iback, stp, xstep)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Character (3) :: word
      Integer :: n, iprint, itfile, iter, nfgv, nact, nseg, iword, iback
      Real (Kind=wp) :: f, sbgnrm, stp, xstep, x(n), g(n)

!     ************
!
!     Subroutine prn2lb
!
!     This subroutine prints out new information after a successful
!       line search.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i, imod

!           'word' records the status of subspace solutions.
      If (iword==0) Then
!                            the subspace minimization converged.
        word = 'con'
      Else If (iword==1) Then
!                          the subspace minimization stopped at a bound.
        word = 'bnd'
      Else If (iword==5) Then
!                             the truncated Newton step has been used.
        word = 'TNT'
      Else
        word = '---'
      End If
      If (iprint>=99) Then
        Write (6, *) 'LINE SEARCH', iback, ' times; norm of step = ', xstep
        Write (6, 110) iter, f, sbgnrm
        If (iprint>100) Then
          Write (6, 100) 'X =', (x(i), i=1, n)
          Write (6, 100) 'G =', (g(i), i=1, n)
        End If
      Else If (iprint>0) Then
        imod = mod(iter, iprint)
        If (imod==0) Write (6, 110) iter, f, sbgnrm
      End If
      If (iprint>=1 .And. itfile/=0) Write (itfile, 120) iter, nfgv, nseg,     &
        nact, word, iback, stp, xstep, sbgnrm, f

100   Format (/, A4, 1P, 6(1X,D11.4), /, (4X,1P,6(1X,D11.4)))
110   Format (/, 'At iterate', I5, 4X, 'f= ', 1P, D12.5, 4X, '|proj g|= ', 1P, &
        D12.5)
120   Format (2(1X,I4), 2(1X,I5), 2X, A3, 1X, I4, 1P, 2(2X,D7.1), 1P, &
        2(1X,D10.3))

      Return

    End Subroutine

!======================= The end of prn2lb =============================

    Subroutine PREC(prn3lb)(n, x, f, task, iprint, info, itfile, iter, nfgv, nintol, &
      nskip, nact, sbgnrm, time, nseg, word, iback, stp, xstep, k, cachyt, &
      sbtime, lnscht)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Character (60) :: task
      Character (3) :: word
      Integer :: n, iprint, info, itfile, iter, nfgv, nintol, nskip, nact, &
        nseg, iback, k
      Real (Kind=wp) :: f, sbgnrm, time, stp, xstep, cachyt, sbtime, lnscht, &
        x(n)

!     ************
!
!     Subroutine prn3lb
!
!     This subroutine prints out information when either a built-in
!       convergence test is satisfied or when an error message is
!       generated.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i

      If (task(1:5)=='ERROR') Go To 100

      If (iprint>=0) Then
        Write (6, 130)
        Write (6, 140)
        Write (6, 150) n, iter, nfgv, nintol, nskip, nact, sbgnrm, f
        If (iprint>=100) Then
          Write (6, 110) 'X =', (x(i), i=1, n)
        End If
        If (iprint>=1) Write (6, *) ' F =', f
      End If
100   Continue
      If (iprint>=0) Then
        Write (6, 180) task
        If (info/=0) Then
          If (info==-1) Write (6, 190)
          If (info==-2) Write (6, 200)
          If (info==-3) Write (6, 210)
          If (info==-4) Write (6, 220)
          If (info==-5) Write (6, 230)
          If (info==-6) Write (6, *) ' Input nbd(', k, ') is invalid.'
          If (info==-7) Write (6, *) ' l(', k, ') > u(', k, &
            ').  No feasible solution.'
          If (info==-8) Write (6, 240)
          If (info==-9) Write (6, 250)
        End If
        If (iprint>=1) Write (6, 160) cachyt, sbtime, lnscht
        Write (6, 170) time
        If (iprint>=1 .And. itfile/=0) Then
          If (info==-4 .Or. info==-9) Then
            Write (itfile, 120) iter, nfgv, nseg, nact, word, iback, stp, &
              xstep
          End If
          Write (itfile, 180) task
          If (info/=0) Then
            If (info==-1) Write (itfile, 190)
            If (info==-2) Write (itfile, 200)
            If (info==-3) Write (itfile, 210)
            If (info==-4) Write (itfile, 220)
            If (info==-5) Write (itfile, 230)
            If (info==-8) Write (itfile, 240)
            If (info==-9) Write (itfile, 250)
          End If
          Write (itfile, 170) time
        End If
      End If

110   Format (/, A4, 1P, 6(1X,D11.4), /, (4X,1P,6(1X,D11.4)))
120   Format (2(1X,I4), 2(1X,I5), 2X, A3, 1X, I4, 1P, 2(2X,D7.1), 6X, '-', &
        10X, '-')
130   Format (/, '           * * *', /, /, &
        'Tit   = total number of iterations', /, &
        'Tnf   = total number of function evaluations', /, &
        'Tnint = total number of segments explored during', &
        ' Cauchy searches', /, 'Skip  = number of BFGS updates skipped', /, &
        'Nact  = number of active bounds at final generalized', &
        ' Cauchy point', /, 'Projg = norm of the final projected gradient', /, &
        'F     = final function value', /, /, '           * * *')
140   Format (/, 3X, 'N', 4X, 'Tit', 5X, 'Tnf', 2X, 'Tnint', 2X, 'Skip', 2X, &
        'Nact', 5X, 'Projg', 8X, 'F')
150   Format (I5, 2(1X,I6), (1X,I6), (2X,I4), (1X,I5), 1P, 2(2X,D10.3))
160   Format (/, ' Cauchy                time', 1P, E10.3, ' seconds.', /, &
        ' Subspace minimization time', 1P, E10.3, ' seconds.', /, &
        ' Line search           time', 1P, E10.3, ' seconds.')
170   Format (/, ' Total User time', 1P, E10.3, ' seconds.', /)
180   Format (/, A60)
190   Format (/, &
        ' Matrix in 1st Cholesky factorization in formk is not Pos. Def.')
200   Format (/, &
        ' Matrix in 2st Cholesky factorization in formk is not Pos. Def.')
210   Format (/, &
        ' Matrix in the Cholesky factorization in formt is not Pos. Def.')
220   Format (/, ' Derivative >= 0, backtracking line search impossible.', /, &
        '   Previous x, f and g restored.', /, &
        ' Possible causes: 1 error in function or gradient evaluation;', /, &
        '                  2 rounding errors dominate computation.')
230   Format (/, ' Warning:  more than 10 function and gradient', /, &
        '   evaluations in the last line search.  Termination', /, &
        '   may possibly be caused by a bad search direction.')
240   Format (/, ' The triangular system is singular.')
250   Format (/, &
        ' Line search cannot locate an adequate point after 20 function', /, &
        '  and gradient evaluations.  Previous x, f and g restored.', /, &
        ' Possible causes: 1 error in function or gradient evaluation;', /, &
        '                  2 rounding error dominate computation.')

      Return

    End Subroutine

!======================= The end of prn3lb =============================

    Subroutine PREC(projgr)(n, l, u, nbd, x, g, sbgnrm)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif

      Integer :: n, nbd(n)
      Real (Kind=wp) :: sbgnrm, x(n), l(n), u(n), g(n)

!     ************
!
!     Subroutine projgr
!
!     This subroutine computes the infinity norm of the projected
!       gradient.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: i
      Real (Kind=wp) :: gi
      Real (Kind=wp) :: one, zero
      Parameter (one=1.0E0_wp, zero=0.0E0_wp)

      sbgnrm = zero
      Do i = 1, n
        gi = g(i)
        If (nbd(i)/=0) Then
          If (gi<zero) Then
            If (nbd(i)>=2) gi = max((x(i)-u(i)), gi)
          Else
            If (nbd(i)<=2) gi = min((x(i)-l(i)), gi)
          End If
        End If
        sbgnrm = max(sbgnrm, abs(gi))
      End Do

      Return

    End Subroutine

!======================= The end of projgr =============================

    Subroutine PREC(subsm)(n, m, nsub, ind, l, u, nbd, x, d, xp, ws, wy, theta, xx, &
      gg, col, head, iword, wv, wn, iprint, info)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif
      Implicit None
      Integer :: n, m, nsub, col, head, iword, iprint, info, ind(nsub), nbd(n)
      Real (Kind=wp) :: theta, l(n), u(n), x(n), d(n), xp(n), xx(n), gg(n), &
        ws(n, m), wy(n, m), wv(2*m), wn(2*m, 2*m)

!     **********************************************************************
!
!     This routine contains the major changes in the updated version.
!     The changes are described in the accompanying paper
!
!      Jose Luis Morales, Jorge Nocedal
!      "Remark On Algorithm 788: L-BFGS-B: Fortran Subroutines for Large-Scale
!       Bound Constrained Optimization". Decemmber 27, 2010.
!
!             J.L. Morales  Departamento de Matematicas,
!                           Instituto Tecnologico Autonomo de Mexico
!                           Mexico D.F.
!
!             J, Nocedal    Department of Electrical Engineering and
!                           Computer Science.
!                           Northwestern University. Evanston, IL. USA
!
!                           January 17, 2011
!
!      **********************************************************************
!
!
!     Subroutine subsm
!
!     Given xcp, l, u, r, an index set that specifies
!       the active set at xcp, and an l-BFGS matrix B
!       (in terms of WY, WS, SY, WT, head, col, and theta),
!       this subroutine computes an approximate solution
!       of the subspace problem
!
!       (P)   min Q(x) = r'(x-xcp) + 1/2 (x-xcp)' B (x-xcp)
!
!             subject to l<=x<=u
!                       x_i=xcp_i for all i in A(xcp)
!
!       along the subspace unconstrained Newton direction
!
!          d = -(Z'BZ)^(-1) r.
!
!       The formula for the Newton direction, given the L-BFGS matrix
!       and the Sherman-Morrison formula, is
!
!          d = (1/theta)r + (1/theta*2) Z'WK^(-1)W'Z r.
!
!       where
!                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!
!     Note that this procedure for computing d differs
!     from that described in [1]. One can show that the matrix K is
!     equal to the matrix M^[-1]N in that paper.
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     nsub is an integer variable.
!       On entry nsub is the number of free variables.
!       On exit nsub is unchanged.
!
!     ind is an integer array of dimension nsub.
!       On entry ind specifies the coordinate indices of free variables.
!       On exit ind is unchanged.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.
!
!     nbd is a integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x specifies the Cauchy point xcp.
!       On exit x(i) is the minimizer of Q over the subspace of
!                                                        free variables.
!
!     d is a double precision array of dimension n.
!       On entry d is the reduced gradient of Q at xcp.
!       On exit d is the Newton direction of Q.
!
!    xp is a double precision array of dimension n.
!       used to safeguard the projected Newton direction
!
!    xx is a double precision array of dimension n
!       On entry it holds the current iterate
!       On output it is unchanged

!    gg is a double precision array of dimension n
!       On entry it holds the gradient at the current iterate
!       On output it is unchanged
!
!     ws and wy are double precision arrays;
!     theta is a double precision variable;
!     col is an integer variable;
!     head is an integer variable.
!       On entry they store the information defining the
!                                          limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         theta is the scaling factor specifying B_0 = theta I;
!         col is the number of variable metric corrections stored;
!         head is the location of the 1st s- (or y-) vector in S (or Y).
!       On exit they are unchanged.
!
!     iword is an integer variable.
!       On entry iword is unspecified.
!       On exit iword specifies the status of the subspace solution.
!         iword = 0 if the solution is in the box,
!                 1 if some bound is encountered.
!
!     wv is a double precision working array of dimension 2m.
!
!     wn is a double precision array of dimension 2m x 2m.
!       On entry the upper triangle of wn stores the LEL^T factorization
!         of the indefinite matrix
!
!              K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                  [L_a -R_z           theta*S'AA'S ]
!                                                    where E = [-I  0]
!                                                              [ 0  I]
!       On exit wn is unchanged.
!
!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return
!                                  when the matrix K is ill-conditioned.
!
!     Subprograms called:
!
!       Linpack dtrsl.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************

      Integer :: pointr, m2, col2, ibd, jy, js, i, j, k
      Real (Kind=wp) :: alpha, xk, dk, temp1, temp2
      Real (Kind=wp) :: one, zero
      Parameter (one=1.0E0_wp, zero=0.0E0_wp)
!
      Real (Kind=wp) :: dd_p

      If (nsub<=0) Return
      If (iprint>=99) Write (6, 110)

!     Compute wv = W'Zd.

      pointr = head
      Do i = 1, col
        temp1 = zero
        temp2 = zero
        Do j = 1, nsub
          k = ind(j)
          temp1 = temp1 + wy(k, pointr)*d(j)
          temp2 = temp2 + ws(k, pointr)*d(j)
        End Do
        wv(i) = temp1
        wv(col+i) = theta*temp2
        pointr = mod(pointr, m) + 1
      End Do

!     Compute wv:=K^(-1)wv.

      m2 = 2*m
      col2 = 2*col
      Call PREC(trsl)(wn, m2, col2, wv, 11, info)
      If (info/=0) Return
      Do i = 1, col
        wv(i) = -wv(i)
      End Do
      Call PREC(trsl)(wn, m2, col2, wv, 01, info)
      If (info/=0) Return

!     Compute d = (1/theta)d + (1/theta**2)Z'W wv.

      pointr = head
      Do jy = 1, col
        js = col + jy
        Do i = 1, nsub
          k = ind(i)
          d(i) = d(i) + wy(k, pointr)*wv(jy)/theta + ws(k, pointr)*wv(js)
        End Do
        pointr = mod(pointr, m) + 1
      End Do

      Call PREC(scal)(nsub, one/theta, d, 1)
!
!-----------------------------------------------------------------
!     Let us try the projection, d is the Newton direction

      iword = 0

      Call PREC(copy)(n, x, 1, xp, 1)
!
      Do i = 1, nsub
        k = ind(i)
        dk = d(i)
        xk = x(k)
        If (nbd(k)/=0) Then
!
          If (nbd(k)==1) Then ! lower bounds only
            x(k) = max(l(k), xk+dk)
            If (x(k)==l(k)) iword = 1
          Else
!
            If (nbd(k)==2) Then ! upper and lower bounds
              xk = max(l(k), xk+dk)
              x(k) = min(u(k), xk)
              If (x(k)==l(k) .Or. x(k)==u(k)) iword = 1
            Else
!
              If (nbd(k)==3) Then ! upper bounds only
                x(k) = min(u(k), xk+dk)
                If (x(k)==u(k)) iword = 1
              End If
            End If
          End If
!
        Else ! free variables
          x(k) = xk + dk
        End If
      End Do
!
      If (iword==0) Then
        Go To 100
      End If
!
!     check sign of the directional derivative
!
      dd_p = zero
      Do i = 1, n
        dd_p = dd_p + (x(i)-xx(i))*gg(i)
      End Do
      If (dd_p>zero) Then
        Call PREC(copy)(n, xp, 1, x, 1)
        Write (6, *) ' Positive dir derivative in projection '
        Write (6, *) ' Using the backtracking step '
      Else
        Go To 100
      End If
!
!-----------------------------------------------------------------
!
      alpha = one
      temp1 = alpha
      ibd = 0
      Do i = 1, nsub
        k = ind(i)
        dk = d(i)
        If (nbd(k)/=0) Then
          If (dk<zero .And. nbd(k)<=2) Then
            temp2 = l(k) - x(k)
            If (temp2>=zero) Then
              temp1 = zero
            Else If (dk*alpha<temp2) Then
              temp1 = temp2/dk
            End If
          Else If (dk>zero .And. nbd(k)>=2) Then
            temp2 = u(k) - x(k)
            If (temp2<=zero) Then
              temp1 = zero
            Else If (dk*alpha>temp2) Then
              temp1 = temp2/dk
            End If
          End If
          If (temp1<alpha) Then
            alpha = temp1
            ibd = i
          End If
        End If
      End Do

      If (alpha<one) Then
        dk = d(ibd)
        k = ind(ibd)
        If (dk>zero) Then
          x(k) = u(k)
          d(ibd) = zero
        Else If (dk<zero) Then
          x(k) = l(k)
          d(ibd) = zero
        End If
      End If
      Do i = 1, nsub
        k = ind(i)
        x(k) = x(k) + alpha*d(i)
      End Do
!ccccc
100   Continue

      If (iprint>=99) Write (6, 120)

110   Format (/, '----------------SUBSM entered-----------------', /)
120   Format (/, '----------------exit SUBSM --------------------', /)

      Return

    End Subroutine
!====================== The end of subsm ===============================

    Subroutine PREC(csrch)(f, g, stp, ftol, gtol, xtol, stpmin, stpmax, task, &
      isave, dsave)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif
      Character (*) :: task
      Integer :: isave(2)
      Real (Kind=wp) :: f, g, stp, ftol, gtol, xtol, stpmin, stpmax
      Real (Kind=wp) :: dsave(13)
!     **********
!
!     Subroutine dcsrch
!
!     This subroutine finds a step that satisfies a sufficient
!     decrease condition and a curvature condition.
!
!     Each call of the subroutine updates an interval with
!     endpoints stx and sty. The interval is initially chosen
!     so that it contains a minimizer of the modified function
!
!           psi(stp) = f(stp) - f(0) - ftol*stp*f'(0).
!
!     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the
!     interval is chosen so that it contains a minimizer of f.
!
!     The algorithm is designed to find a step that satisfies
!     the sufficient decrease condition
!
!           f(stp) <= f(0) + ftol*stp*f'(0),
!
!     and the curvature condition
!
!           abs(f'(stp)) <= gtol*abs(f'(0)).
!
!     If ftol is less than gtol and if, for example, the function
!     is bounded below, then there is always a step which satisfies
!     both conditions.
!
!     If no step can be found that satisfies both conditions, then
!     the algorithm stops with a warning. In this case stp only
!     satisfies the sufficient decrease condition.
!
!     A typical invocation of dcsrch has the following outline:
!
!     task = 'START'
!  10 continue
!        call dcsrch( ... )
!        if (task .eq. 'FG') then
!           Evaluate the function and the gradient at stp
!           goto 10
!           end if
!
!     NOTE: The user must no alter work arrays between calls.
!
!     The subroutine statement is
!
!        subroutine dcsrch(f,g,stp,ftol,gtol,xtol,stpmin,stpmax,
!                          task,isave,dsave)
!     where
!
!       f is a double precision variable.
!         On initial entry f is the value of the function at 0.
!            On subsequent entries f is the value of the
!            function at stp.
!         On exit f is the value of the function at stp.
!
!       g is a double precision variable.
!         On initial entry g is the derivative of the function at 0.
!            On subsequent entries g is the derivative of the
!            function at stp.
!         On exit g is the derivative of the function at stp.
!
!       stp is a double precision variable.
!         On entry stp is the current estimate of a satisfactory
!            step. On initial entry, a positive initial estimate
!            must be provided.
!         On exit stp is the current estimate of a satisfactory step
!            if task = 'FG'. If task = 'CONV' then stp satisfies
!            the sufficient decrease and curvature condition.
!
!       ftol is a double precision variable.
!         On entry ftol specifies a nonnegative tolerance for the
!            sufficient decrease condition.
!         On exit ftol is unchanged.
!
!       gtol is a double precision variable.
!         On entry gtol specifies a nonnegative tolerance for the
!            curvature condition.
!         On exit gtol is unchanged.
!
!       xtol is a double precision variable.
!         On entry xtol specifies a nonnegative relative tolerance
!            for an acceptable step. The subroutine exits with a
!            warning if the relative difference between sty and stx
!            is less than xtol.
!         On exit xtol is unchanged.
!
!       stpmin is a double precision variable.
!         On entry stpmin is a nonnegative lower bound for the step.
!         On exit stpmin is unchanged.
!
!       stpmax is a double precision variable.
!         On entry stpmax is a nonnegative upper bound for the step.
!         On exit stpmax is unchanged.
!
!       task is a character variable of length at least 60.
!         On initial entry task must be set to 'START'.
!         On exit task indicates the required action:
!
!            If task(1:2) = 'FG' then evaluate the function and
!            derivative at stp and call dcsrch again.
!
!            If task(1:4) = 'CONV' then the search is successful.
!
!            If task(1:4) = 'WARN' then the subroutine is not able
!            to satisfy the convergence conditions. The exit value of
!            stp contains the best point found during the search.
!
!            If task(1:5) = 'ERROR' then there is an error in the
!            input arguments.
!
!         On exit with convergence, a warning or an error, the
!            variable task contains additional information.
!
!       isave is an integer work array of dimension 2.
!
!       dsave is a double precision work array of dimension 13.
!
!     Subprograms called
!
!       MINPACK-2 ... dcstep
!
!     MINPACK-1 Project. June 1983.
!     Argonne National Laboratory.
!     Jorge J. More' and David J. Thuente.
!
!     MINPACK-2 Project. October 1993.
!     Argonne National Laboratory and University of Minnesota.
!     Brett M. Averick, Richard G. Carter, and Jorge J. More'.
!
!     **********
      Real (Kind=wp) :: zero, p5, p66
      Parameter (zero=0.0E0_wp, p5=0.5E0_wp, p66=0.66E0_wp)
      Real (Kind=wp) :: xtrapl, xtrapu
      Parameter (xtrapl=1.1E0_wp, xtrapu=4.0E0_wp)

      Logical :: brackt
      Integer :: stage
      Real (Kind=wp) :: finit, ftest, fm, fx, fxm, fy, fym, ginit, gtest, gm, &
        gx, gxm, gy, gym, stx, sty, stmin, stmax, width, width1

!     Initialization block.

      If (task(1:5)=='START') Then

!        Check the input arguments for errors.

        If (stp<stpmin) task = 'ERROR: STP .LT. STPMIN'
        If (stp>stpmax) task = 'ERROR: STP .GT. STPMAX'
        If (g>=zero) task = 'ERROR: INITIAL G .GE. ZERO'
        If (ftol<zero) task = 'ERROR: FTOL .LT. ZERO'
        If (gtol<zero) task = 'ERROR: GTOL .LT. ZERO'
        If (xtol<zero) task = 'ERROR: XTOL .LT. ZERO'
        If (stpmin<zero) task = 'ERROR: STPMIN .LT. ZERO'
        If (stpmax<stpmin) task = 'ERROR: STPMAX .LT. STPMIN'

!        Exit if there are errors on input.

        If (task(1:5)=='ERROR') Return

!        Initialize local variables.

        brackt = .False.
        stage = 1
        finit = f
        ginit = g
        gtest = ftol*ginit
        width = stpmax - stpmin
        width1 = width/p5

!        The variables stx, fx, gx contain the values of the step,
!        function, and derivative at the best step.
!        The variables sty, fy, gy contain the value of the step,
!        function, and derivative at sty.
!        The variables stp, f, g contain the values of the step,
!        function, and derivative at stp.

        stx = zero
        fx = finit
        gx = ginit
        sty = zero
        fy = finit
        gy = ginit
        stmin = zero
        stmax = stp + xtrapu*stp
        task = 'FG'

        Go To 100

      Else

!        Restore local variables.

        If (isave(1)==1) Then
          brackt = .True.
        Else
          brackt = .False.
        End If
        stage = isave(2)
        ginit = dsave(1)
        gtest = dsave(2)
        gx = dsave(3)
        gy = dsave(4)
        finit = dsave(5)
        fx = dsave(6)
        fy = dsave(7)
        stx = dsave(8)
        sty = dsave(9)
        stmin = dsave(10)
        stmax = dsave(11)
        width = dsave(12)
        width1 = dsave(13)

      End If

!     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the
!     algorithm enters the second stage.

      ftest = finit + stp*gtest
      If (stage==1 .And. f<=ftest .And. g>=zero) stage = 2

!     Test for warnings.

      If (brackt .And. (stp<=stmin .Or. stp>=stmax)) &
        task = 'WARNING: ROUNDING ERRORS PREVENT PROGRESS'
      If (brackt .And. stmax-stmin<=xtol*stmax) task = &
        'WARNING: XTOL TEST SATISFIED'
      If (stp==stpmax .And. f<=ftest .And. g<=gtest) &
        task = 'WARNING: STP = STPMAX'
      If (stp==stpmin .And. (f>ftest .Or. g>=gtest)) &
        task = 'WARNING: STP = STPMIN'

!     Test for convergence.

      If (f<=ftest .And. abs(g)<=gtol*(-ginit)) task = 'CONVERGENCE'

!     Test for termination.

      If (task(1:4)=='WARN' .Or. task(1:4)=='CONV') Go To 100

!     A modified function is used to predict the step during the
!     first stage if a lower function value has been obtained but
!     the decrease is not sufficient.

      If (stage==1 .And. f<=fx .And. f>ftest) Then

!        Define the modified function and derivative values.

        fm = f - stp*gtest
        fxm = fx - stx*gtest
        fym = fy - sty*gtest
        gm = g - gtest
        gxm = gx - gtest
        gym = gy - gtest

!        Call dcstep to update stx, sty, and to compute the new step.

        Call PREC(cstep)(stx, fxm, gxm, sty, fym, gym, stp, fm, gm, brackt, stmin, &
          stmax)

!        Reset the function and derivative values for f.

        fx = fxm + stx*gtest
        fy = fym + sty*gtest
        gx = gxm + gtest
        gy = gym + gtest

      Else

!       Call dcstep to update stx, sty, and to compute the new step.

        Call PREC(cstep)(stx, fx, gx, sty, fy, gy, stp, f, g, brackt, stmin, stmax)

      End If

!     Decide if a bisection step is needed.

      If (brackt) Then
        If (abs(sty-stx)>=p66*width1) stp = stx + p5*(sty-stx)
        width1 = width
        width = abs(sty-stx)
      End If

!     Set the minimum and maximum steps allowed for stp.

      If (brackt) Then
        stmin = min(stx, sty)
        stmax = max(stx, sty)
      Else
        stmin = stp + xtrapl*(stp-stx)
        stmax = stp + xtrapu*(stp-stx)
      End If

!     Force the step to be within the bounds stpmax and stpmin.

      stp = max(stp, stpmin)
      stp = min(stp, stpmax)

!     If further progress is not possible, let stp be the best
!     point obtained during the search.

      If (brackt .And. (stp<=stmin .Or. stp>=stmax) .Or. &
        (brackt .And. stmax-stmin<=xtol*stmax)) stp = stx

!     Obtain another function and derivative.

      task = 'FG'

100   Continue

!     Save local variables.

      If (brackt) Then
        isave(1) = 1
      Else
        isave(1) = 0
      End If
      isave(2) = stage
      dsave(1) = ginit
      dsave(2) = gtest
      dsave(3) = gx
      dsave(4) = gy
      dsave(5) = finit
      dsave(6) = fx
      dsave(7) = fy
      dsave(8) = stx
      dsave(9) = sty
      dsave(10) = stmin
      dsave(11) = stmax
      dsave(12) = width
      dsave(13) = width1

      Return
    End Subroutine

!====================== The end of dcsrch ==============================

    Subroutine PREC(cstep)(stx, fx, dx, sty, fy, dy, stp, fp, dp, brackt, stpmin, &
      stpmax)
#ifdef SINGLE_PREC
   Use sworking_precision, Only: wp
#else
   Use dworking_precision, Only: wp
#endif
      Logical :: brackt
      Real (Kind=wp) :: stx, fx, dx, sty, fy, dy, stp, fp, dp, stpmin, stpmax
!     **********
!
!     Subroutine dcstep
!
!     This subroutine computes a safeguarded step for a search
!     procedure and updates an interval that contains a step that
!     satisfies a sufficient decrease and a curvature condition.
!
!     The parameter stx contains the step with the least function
!     value. If brackt is set to .true. then a minimizer has
!     been bracketed in an interval with endpoints stx and sty.
!     The parameter stp contains the current step.
!     The subroutine assumes that if brackt is set to .true. then
!
!           min(stx,sty) < stp < max(stx,sty),
!
!     and that the derivative at stx is negative in the direction
!     of the step.
!
!     The subroutine statement is
!
!       subroutine dcstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,
!                         stpmin,stpmax)
!
!     where
!
!       stx is a double precision variable.
!         On entry stx is the best step obtained so far and is an
!            endpoint of the interval that contains the minimizer.
!         On exit stx is the updated best step.
!
!       fx is a double precision variable.
!         On entry fx is the function at stx.
!         On exit fx is the function at stx.
!
!       dx is a double precision variable.
!         On entry dx is the derivative of the function at
!            stx. The derivative must be negative in the direction of
!            the step, that is, dx and stp - stx must have opposite
!            signs.
!         On exit dx is the derivative of the function at stx.
!
!       sty is a double precision variable.
!         On entry sty is the second endpoint of the interval that
!            contains the minimizer.
!         On exit sty is the updated endpoint of the interval that
!            contains the minimizer.
!
!       fy is a double precision variable.
!         On entry fy is the function at sty.
!         On exit fy is the function at sty.
!
!       dy is a double precision variable.
!         On entry dy is the derivative of the function at sty.
!         On exit dy is the derivative of the function at the exit sty.
!
!       stp is a double precision variable.
!         On entry stp is the current step. If brackt is set to .true.
!            then on input stp must be between stx and sty.
!         On exit stp is a new trial step.
!
!       fp is a double precision variable.
!         On entry fp is the function at stp
!         On exit fp is unchanged.
!
!       dp is a double precision variable.
!         On entry dp is the the derivative of the function at stp.
!         On exit dp is unchanged.
!
!       brackt is an logical variable.
!         On entry brackt specifies if a minimizer has been bracketed.
!            Initially brackt must be set to .false.
!         On exit brackt specifies if a minimizer has been bracketed.
!            When a minimizer is bracketed brackt is set to .true.
!
!       stpmin is a double precision variable.
!         On entry stpmin is a lower bound for the step.
!         On exit stpmin is unchanged.
!
!       stpmax is a double precision variable.
!         On entry stpmax is an upper bound for the step.
!         On exit stpmax is unchanged.
!
!     MINPACK-1 Project. June 1983
!     Argonne National Laboratory.
!     Jorge J. More' and David J. Thuente.
!
!     MINPACK-2 Project. October 1993.
!     Argonne National Laboratory and University of Minnesota.
!     Brett M. Averick and Jorge J. More'.
!
!     **********
      Real (Kind=wp) :: zero, p66, two, three
      Parameter (zero=0.0E0_wp, p66=0.66E0_wp, two=2.0E0_wp, three=3.0E0_wp)

      Real (Kind=wp) :: gamma, p, q, r, s, sgnd, stpc, stpf, stpq, theta

      sgnd = dp*(dx/abs(dx))

!     First case: A higher function value. The minimum is bracketed.
!     If the cubic step is closer to stx than the quadratic step, the
!     cubic step is taken, otherwise the average of the cubic and
!     quadratic steps is taken.

      If (fp>fx) Then
        theta = three*(fx-fp)/(stp-stx) + dx + dp
        s = max(abs(theta), abs(dx), abs(dp))
        gamma = s*sqrt((theta/s)**2-(dx/s)*(dp/s))
        If (stp<stx) gamma = -gamma
        p = (gamma-dx) + theta
        q = ((gamma-dx)+gamma) + dp
        r = p/q
        stpc = stx + r*(stp-stx)
        stpq = stx + ((dx/((fx-fp)/(stp-stx)+dx))/two)*(stp-stx)
        If (abs(stpc-stx)<abs(stpq-stx)) Then
          stpf = stpc
        Else
          stpf = stpc + (stpq-stpc)/two
        End If
        brackt = .True.

!     Second case: A lower function value and derivatives of opposite
!     sign. The minimum is bracketed. If the cubic step is farther from
!     stp than the secant step, the cubic step is taken, otherwise the
!     secant step is taken.

      Else If (sgnd<zero) Then
        theta = three*(fx-fp)/(stp-stx) + dx + dp
        s = max(abs(theta), abs(dx), abs(dp))
        gamma = s*sqrt((theta/s)**2-(dx/s)*(dp/s))
        If (stp>stx) gamma = -gamma
        p = (gamma-dp) + theta
        q = ((gamma-dp)+gamma) + dx
        r = p/q
        stpc = stp + r*(stx-stp)
        stpq = stp + (dp/(dp-dx))*(stx-stp)
        If (abs(stpc-stp)>abs(stpq-stp)) Then
          stpf = stpc
        Else
          stpf = stpq
        End If
        brackt = .True.

!     Third case: A lower function value, derivatives of the same sign,
!     and the magnitude of the derivative decreases.

      Else If (abs(dp)<abs(dx)) Then

!        The cubic step is computed only if the cubic tends to infinity
!        in the direction of the step or if the minimum of the cubic
!        is beyond stp. Otherwise the cubic step is defined to be the
!        secant step.

        theta = three*(fx-fp)/(stp-stx) + dx + dp
        s = max(abs(theta), abs(dx), abs(dp))

!        The case gamma = 0 only arises if the cubic does not tend
!        to infinity in the direction of the step.

        gamma = s*sqrt(max(zero,(theta/s)**2-(dx/s)*(dp/s)))
        If (stp>stx) gamma = -gamma
        p = (gamma-dp) + theta
        q = (gamma+(dx-dp)) + gamma
        r = p/q
        If (r<zero .And. gamma/=zero) Then
          stpc = stp + r*(stx-stp)
        Else If (stp>stx) Then
          stpc = stpmax
        Else
          stpc = stpmin
        End If
        stpq = stp + (dp/(dp-dx))*(stx-stp)

        If (brackt) Then

!           A minimizer has been bracketed. If the cubic step is
!           closer to stp than the secant step, the cubic step is
!           taken, otherwise the secant step is taken.

          If (abs(stpc-stp)<abs(stpq-stp)) Then
            stpf = stpc
          Else
            stpf = stpq
          End If
          If (stp>stx) Then
            stpf = min(stp+p66*(sty-stp), stpf)
          Else
            stpf = max(stp+p66*(sty-stp), stpf)
          End If
        Else

!           A minimizer has not been bracketed. If the cubic step is
!           farther from stp than the secant step, the cubic step is
!           taken, otherwise the secant step is taken.

          If (abs(stpc-stp)>abs(stpq-stp)) Then
            stpf = stpc
          Else
            stpf = stpq
          End If
          stpf = min(stpmax, stpf)
          stpf = max(stpmin, stpf)
        End If

!     Fourth case: A lower function value, derivatives of the same sign,
!     and the magnitude of the derivative does not decrease. If the
!     minimum is not bracketed, the step is either stpmin or stpmax,
!     otherwise the cubic step is taken.

      Else
        If (brackt) Then
          theta = three*(fp-fy)/(sty-stp) + dy + dp
          s = max(abs(theta), abs(dy), abs(dp))
          gamma = s*sqrt((theta/s)**2-(dy/s)*(dp/s))
          If (stp>sty) gamma = -gamma
          p = (gamma-dp) + theta
          q = ((gamma-dp)+gamma) + dy
          r = p/q
          stpc = stp + r*(sty-stp)
          stpf = stpc
        Else If (stp>stx) Then
          stpf = stpmax
        Else
          stpf = stpmin
        End If
      End If

!     Update the interval which contains a minimizer.

      If (fp>fx) Then
        sty = stp
        fy = fp
        dy = dp
      Else
        If (sgnd<zero) Then
          sty = stx
          fy = fx
          dy = dx
        End If
        stx = stp
        fx = fp
        dx = dp
      End If

!     Compute the new step.

      stp = stpf

      Return
    End Subroutine
